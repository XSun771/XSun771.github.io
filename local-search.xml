<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Mutual SSL in Spring With Self-Signed Certificate</title>
    <link href="/2023/05/23/Mutual-SSL-in-Spring-With-Self-Signed-Certificate/"/>
    <url>/2023/05/23/Mutual-SSL-in-Spring-With-Self-Signed-Certificate/</url>
    
    <content type="html"><![CDATA[<h1 id="SSL-知识"><a href="#SSL-知识" class="headerlink" title="SSL 知识"></a>SSL 知识</h1><h2 id="能够建立彼此信任通讯的数学基石"><a href="#能够建立彼此信任通讯的数学基石" class="headerlink" title="能够建立彼此信任通讯的数学基石"></a>能够建立彼此信任通讯的数学基石</h2><p>非对称算法中的密钥对具有这样的特性</p><p>（1） 若内容被这对密钥中的密钥A所加密，则只能使用密钥B解密，密钥A自己都不能解密得到原来的内容。反之，密钥B加密的内容也只有密钥A能解密。</p><p>（2）不可能使用密钥A推出密钥B。</p><p>（3）非对称密钥对有无穷多个且不难生成。</p><p>由此，试图通讯的甲乙双方可以自己生产自己的非对称算法密钥对，并毫无顾忌地分享其中一个（这个被分享出去的称为<strong>公钥</strong>）同时谨慎地保管另一个（称为<strong>私钥</strong>）。此时，甲若用乙分享的公钥加密了一段自己刚随便生成没有公开的内容，然后将这个加密公开出去，不考虑无限次尝试，碰巧以及乙私钥泄露的情况，那么只有乙能用自己的私钥解密得到这个内容。进而，谁能告诉乙他之前公开的加密内容所对应的原内容是啥，那么那个人一定是甲。</p><p>由此，通讯双方可以确认自己在和谁通信，并且在使用公钥加密的基础上，通信内容也只有对方可以解密。</p><h2 id="诡计多端的中间人"><a href="#诡计多端的中间人" class="headerlink" title="诡计多端的中间人"></a>诡计多端的中间人</h2><p>由上一节我们知道，只要甲和乙已经获知了彼此的公钥，那么甲和乙就可以彼此验明正身，交换只有彼此可知的信息。</p><p>但『只要甲和乙已经获知了彼此的公钥』这个条件并不是那么容易确保的。如果有一个中间人丙，它对甲说自己的公钥是乙的公钥，对乙说自己的公钥是甲的公钥。 那么甲就会把丙当做乙，乙也会把丙当做甲。此时甲和乙之间的通讯内容也对丙完全透明了，因为他们加密用的是丙的公钥，自然可以被丙的私钥解密。</p><p>怎么避免这样的<strong>中间人攻击</strong>呢？</p><p>（1）操作系统都内置一些可信的权威机构的公钥。</p><p>（2）不想被中间人顶替自己蒙骗自己的通讯者的那一方，向这些被操作系统默认内置的权威机构中的一个注册自己的公钥和自己的信息，并拿到由那个机构基于它的私钥和信息后加密的结果。</p><p>（3）所有通讯的发起者在验明正身的时候，都必须让另一方说明自己是注册在了哪个权威机构。然后用系统内置的那个权威机构的公钥对内容解密，获得其中的公钥。</p><p>中间人此时无法拿自己的公钥来伪造这里的公钥，因为：</p><p>（1）中间人是不可信的违法犯罪者，没有权威机构的私钥，它使用另外一个私钥的加密结果，用正确的公钥解密，解密的结果里的公钥也不可能是他自己的公钥。而且解密出来的其它信息，比如IP信息（或者域名信息）也往往是不可对或者与通讯发起者的目标不一致的，这都会导致通讯发起者认为没有与对的目标建立其绘画</p><p>（2）由于非对称加密密钥对的性质，无法基于公钥解密的结果，去反推用公钥加密前的内容应该长什么样。</p><p>这里的权威机构就是我们说的 CA (Certificate Authority), 也即<strong>数字证书认证机构</strong>。</p><h2 id="证书与相关概念"><a href="#证书与相关概念" class="headerlink" title="证书与相关概念"></a>证书与相关概念</h2><table><tr/><td>CA</td> <td>Certificate Authority</td> <td>数字证书认证机构</td> <td></td><tr/><tr/><td>CSR</td> <td>* Certificate Signing Request</td> <td>凭证签发请求</td> <td>站点在向全文机构申请证书前准备的自己的资料（包含公钥但不应当包含私钥）。CA 基于 CSR 签发 Cert。</td><tr/><tr><td>Cert</td> <td>Certificate</td> <td>证书</td> <td>一般公钥以及站点的信息已经封装在其中。</td></tr><tr><td>X.509</td> <td>X.509</td> <td></td> <td>X.509是密码学里公钥证书的格式标准。符合X.509标准的证书里含有公钥、身份信息（比如网络主机名，组织的名称或个体名称等）和签名信息（可以是证书签发机构CA的签名，也可以是自签名）。这是最流行的证书标准。</td></tr><tr><td>Key</td> <td>Private Key</td> <td>私钥</td> <td>因为公钥一般都封装在证书中，因此在和 Cert 同时出现的语境中，一般就简单地指私钥。比如保存私钥的文件的后缀名便是key。</td></tr><tr><td>KeyStore</td> <td>KeyStore</td> <td>无公认的中文说法</td> <td>一个 KeyStore 中可以存放多组密钥对，或证书私钥对，亦或者不成对的。KeyStore 是对 SSL 资料的打包，将多个 SSL 资料文件合并为一个方便使用。</td></tr><td>Self-signed CA/Cert</td> <td>Self-signed CA/Cert</td> <td>自签名CA/证书</td> <td>在局域网，比如公司的内网，只要这个局域网的参与者认可的 CA，以及由这个 CA 签发的证书。</td></tr></tr><td>Mutual SSL/2-way SSL</td> <td>Mutual SSL/2-way SSL</td> <td>SSL双向认证</td> <td>常见的浏览器访问 HTTPS 的站点，其实只是单向验证。我们验证了站点的身份，但站点并不验证我们的身份。而通讯双方都需要彼此验明正身的，就是 SSL 双向认证。</td></tr></tr><td>PKCS</td> <td>Public Key Cryptography Standards</td> <td>公钥加密标准</td> <td>PKCS #10为 证书申请标准（Certification Request Standard）, 规范了向证书中心申请证书之CSR（certificate signing request）的格式。PKCS 下共有15个子项，每个子项对应一个公钥加密标准的所涉及的技术的标准规范。</td></tr></tr><td>openssl</td> <td></td> <td></td> <td>openssl 是一个命令，也是一个开源工具库，其实现了基本的加密功能，实现了SSL与TLS协议，是生成 SSL 和 TLS 的必要材料的基础工具。</td></tr><td>keytool</td> <td></td> <td></td> <td>keytool 是 JDK 中负责 SSL/TLS 和 keystore 的工具。可以帮助生成，管理和阅读 keystore 文件。</td></tr></table><p>** 亦可用 Certificate Request 指 CSR，在 openssl 的 Linux 手册中，使用 Certificate Request 而非 Certificate Signing Request，但说的是同一个东西。</p><h1 id="Self-signed-CA"><a href="#Self-signed-CA" class="headerlink" title="Self-signed CA"></a>Self-signed CA</h1><p>我在自己的 windows PC 上开了一个 Unbutun 的虚拟机，在更新了 openssh，安装 Java 环境（确保 JDK 中的 keytool 可用）后，使用这个虚拟机作为自签名 CA 来签发 Cert。</p><p>参考资料：</p><ul><li><a href="https://www.baeldung.com/x-509-authentication-in-spring-security">X.509 Authentication in Spring Security</a> </li><li><a href="https://linux.die.net/man/1/openssl">man openssl</a></li><li><a href="https://linux.die.net/man/1/req">man openssl req</a></li><li><a href="https://linux.die.net/man/1/x509">man oepnssl x509</a></li><li><a href="https://linux.die.net/man/1/pkcs12">man openssl pkcs12</a></li><li><a href="https://www.mankier.com/1/keytool">man keytool</a></li></ul><p>作为CA，我们也需要有自己的证书，使用如下命令创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -x509 -sha256 -days 3650 -newkey rsa:4096 -keyout rootCA.key -out rootCA.crt<br></code></pre></td></tr></table></figure><ul><li>openssl: OpenSSL is a cryptography toolkit implementing the Secure Sockets Layer (SSL v2&#x2F;v3) and Transport Layer Security (TLS v1) network protocols and related cryptography standards required by them. The openssl program is a command line tool for using the various cryptography functions of OpenSSL’s crypto library from the shell.</li><li>req: PKCS#10 X.509 Certificate Signing Request ( CSR ) Management.</li><li>-x509: <strong>this option outputs a self signed certificate instead of a certificate request</strong>. This is typically used to generate a test certificate or a self signed root CA . </li><li>-sha256: -[digest] this specifies the message digest to sign the request with (such as -md5, -sha1). Here, the digest is sha256. 指定生成的证书中，证书内容的摘要所用的算法。此处为 SHA256。</li><li>-days 3650: 该证书将在 3650 天后过期。</li><li>-newkey rsa:4096: this option creates a new certificate request and a new private key. The argument takes one of several forms. rsa:nbits, where nbits is the number of bits, generates an RSA key nbits in size. If nbits is omitted, i.e. -newkey rsa specified, the default key size, specified in the configuration file is used.</li><li>-keyout rootCA.key: 将生成的私钥保存到当前工作路径下的 rootCA.key 文件。</li><li>-out rootCA.crt: 将生成的证书保存为工作路径下的 rootCA.crt 文件。</li></ul><p>这个命令执行后，会要求你输入一个密码以保护私钥。这个密码会加密私钥，但这不意味着 rootCA.key 文件用记事本打开会是大片乱码。</p><p>同时，这个命令也会要求你输入这个证书所颁发的对象的基本信息，如所在的国家，省份，市区，公司单位名称以及 Common Name，就像下面一样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-----</span><br>You are about <span class="hljs-keyword">to</span> be asked <span class="hljs-keyword">to</span> enter information that will be incorporated<br><span class="hljs-keyword">into</span> your certificate request.<br>What you are about <span class="hljs-keyword">to</span> enter <span class="hljs-keyword">is</span> what <span class="hljs-keyword">is</span> <span class="hljs-keyword">called</span> a Distinguished <span class="hljs-type">Name</span> <span class="hljs-keyword">or</span> a DN.<br>There are quite a few fields but you can leave <span class="hljs-keyword">some</span> blank<br><span class="hljs-keyword">For</span> <span class="hljs-keyword">some</span> fields there will be a <span class="hljs-keyword">default</span> <span class="hljs-keyword">value</span>,<br><span class="hljs-keyword">If</span> you enter <span class="hljs-string">&#x27;.&#x27;</span>, the field will be left blank.<br><span class="hljs-comment">-----</span><br>Country <span class="hljs-type">Name</span> (<span class="hljs-number">2</span> letter code) [AU]:CN <br>State <span class="hljs-keyword">or</span> Province <span class="hljs-type">Name</span> (<span class="hljs-keyword">full</span> <span class="hljs-type">name</span>) [<span class="hljs-keyword">Some</span>-State]:SH<br>Locality <span class="hljs-type">Name</span> (eg, city) []:SH<br>Organization <span class="hljs-type">Name</span> (eg, company) [Internet Widgits Pty Ltd]:NA<br>Organizational Unit <span class="hljs-type">Name</span> (eg, section) []:NA<br>Common <span class="hljs-type">Name</span> (e.g. <span class="hljs-keyword">server</span> FQDN <span class="hljs-keyword">or</span> YOUR <span class="hljs-type">name</span>) []:bob<br>Email Address []:.<br><br>Please enter the <span class="hljs-keyword">following</span> <span class="hljs-string">&#x27;extra&#x27;</span> attributes<br><span class="hljs-keyword">to</span> be sent <span class="hljs-keyword">with</span> your certificate request<br>A challenge <span class="hljs-keyword">password</span> []:abc<br>String too short, must be at least <span class="hljs-number">4</span> bytes long<br>A challenge <span class="hljs-keyword">password</span> []:abcde<br>An optional company <span class="hljs-type">name</span> []:NA<br></code></pre></td></tr></table></figure><p>所有生产证书的指令都会要求这些信息，包括使用此时生成的根证书签发新的证书。</p><h1 id="能与服务端建立单向-SSL-连接"><a href="#能与服务端建立单向-SSL-连接" class="headerlink" title="能与服务端建立单向 SSL 连接"></a>能与服务端建立单向 SSL 连接</h1><p>在 Windows PC 上写 Spring 程序，写好之后 jar 包扔到虚拟机上跑。虚拟机的 IP 是 <code>192.168.19.128</code>。要让 <code>https://192.168.19.128/</code> 能够被成功访问，要为这个程序签发证书并让程序加载它，在收到 SSL 请求时使用它。</p><h2 id="生成-CSR"><a href="#生成-CSR" class="headerlink" title="生成 CSR"></a>生成 CSR</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -new -newkey rsa:4096 -keyout localhost.key -out localhost.csr<br></code></pre></td></tr></table></figure><ul><li>-new: this option generates a new certificate request.</li><li>-out localhost.csr: 生成的 CSR 保存为工作路径下的 localhost.scr 文件。</li></ul><h2 id="获得-Cert-所需的其它信息"><a href="#获得-Cert-所需的其它信息" class="headerlink" title="获得 Cert 所需的其它信息"></a>获得 Cert 所需的其它信息</h2><p>在当前工作路径下创建 localhost.ext 文件，内容如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">authorityKeyIdentifier</span>=keyid,issuer<br><span class="hljs-attr">basicConstraints</span>=CA:<span class="hljs-literal">FALSE</span><br><span class="hljs-attr">subjectAltName</span> = @alt_names<br><span class="hljs-section">[alt_names]</span><br><span class="hljs-attr">IP.1</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">19.128</span><br></code></pre></td></tr></table></figure><p>如果使用的是域名而非 IP，则 IP.1 那一行可以改为 <code>DNS.1 = localhost</code>。</p><h2 id="使用-Self-signed-CA-签发-localhost-证书"><a href="#使用-Self-signed-CA-签发-localhost-证书" class="headerlink" title="使用 Self-signed CA 签发 localhost 证书"></a>使用 Self-signed CA 签发 localhost 证书</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl x509 -req -CA rootCA.crt -CAkey rootCA.key -in localhost.csr -out localhost.crt -days 365 -CAcreateserial -extfile localhost.ext<br></code></pre></td></tr></table></figure><ul><li>-CA rootCA.crt: 指定签发证书的 CA 的证书是在当前工作路径下的 rootCA.crt 文件。</li><li>-CAkey rootCA.key：指定签发证书的 CA 的私钥保存在 rootCA.key 文件中。</li><li>-in localhost.scr: 请求证书者的简历，其中最重要的是包含公钥。</li><li>-out localhost.crt: 为请求者签发的证书输出为当前工作目录下的 locahost.crt 文件</li><li>-days 365: 签发的这个证书有效期为 365 天，即一年。</li><li>-CAcreateserial: with this option the CA serial number file is created if it does not exist: it will contain the serial number “02” and the certificate being signed will have the 1 as its serial number. Normally if the -CA option is specified and the serial number file does not exist it is an error.</li><li>-extfile localhost.ext: 在签发证书的时，参考 localhost.ext 进行签发并在证书中写入对应信息。</li></ul><p>有了这个证书之后，就可以让虚拟机上运行的 spring boot 程序加载它，进而做到使用 https 访问该 spring boot 程序。</p><p>不过我们需要先将证书 (localhost.crt) 和私钥 （localhost.key）打包为一个 keystore。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl pkcs12 -export -out localhost.p12 -name &quot;localhost&quot; -inkey localhost.key -in localhost.crt<br></code></pre></td></tr></table></figure><ul><li>pkcs12: The pkcs12 command allows PKCS#12 files (sometimes referred to as PFX files) to be created and parsed.</li><li>-export: This option specifies that a PKCS#12 file will be created rather than parsed.</li><li>-out localhost.p12: 创建的 pkcs12 的 keystore 保存为工作目录下的 localhost.p12 文件。</li><li>-name: This specifies the “friendly name” for the certificate and private key. This name is typically displayed in list boxes by software importing the file.</li><li>-inkey localhost.key: 指明私钥保存在工作目录下的 localhost.key 文件中。</li><li>-in localhost.crt: 指明证书保存在工作目录下的 localhost.crt 文件中。</li></ul><p>此命令执行后会需要输入私钥的密码。</p><h2 id="配置-Spring-Boot-程序"><a href="#配置-Spring-Boot-程序" class="headerlink" title="配置 Spring Boot 程序"></a>配置 Spring Boot 程序</h2><p>在配置文件中添加如下配置，从而告知 Spring Boot 服务 enable SSL 以及有人试图与它建立 SSL 连接时，使用何处的证书：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">server.ssl.enabled</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">server.ssl.key-store</span>=/root/localhost.p12<br><span class="hljs-attr">server.ssl.key-store-password</span>=bob<br><span class="hljs-attr">server.ssl.key-alias</span>=localhost<br><span class="hljs-attr">server.ssl.key-password</span>=bob<br><span class="hljs-attr">server.port</span>=<span class="hljs-number">8443</span><br></code></pre></td></tr></table></figure><p>除此之外在一个 <code>@RestController</code> 的类下增加一个 RequestMapping:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME);<br>&#125;<br></code></pre></td></tr></table></figure><p>随后在 Windows PC 上用 <code>https://192.168.19.128/</code> 访问这个地址，会发现浏览器警告建立的连接是不可靠的。</p><h2 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h2><p>在 Windows PC 上用 <code>https://192.168.19.128/</code> 访问这个地址，会发现浏览器警告建立的连接是不可靠的。</p><p>这是因为 Self-signed CA 并不是权威的，广受信任的证书签发机构，因此其证书并未内置在 Windows 系统的信任证书库中。</p><p>我们必须先将 <code>rootCA.cer</code> 证书从虚拟机中下载到 Windows PC，并安装在『受信任的根证书颁发机构』中。随后重启浏览器再次访问，才能一切顺利。</p><p>同时在『获得 Cert 所需的其它信息』中我们提到 <code>IP.1 = 192.168.19.128</code> 这样一个配置。这里配置的 IP 地址会被填入到 <code>localhost.cer</code> 中。浏览器与 Spring Boot 程序建立 SSL 连接时，会收到 Spring Boot 发来的 <code>localhost.cer</code>，并校验自己的目的地与证书中的这个 IP.1 是不是一致。如果不一致，则即便信任根证书，也依然警告该 SSL 连接不安全。</p><h1 id="客户端能与服务端建立双向-SSL-连接"><a href="#客户端能与服务端建立双向-SSL-连接" class="headerlink" title="客户端能与服务端建立双向 SSL 连接"></a>客户端能与服务端建立双向 SSL 连接</h1><h2 id="为客户端签发证书"><a href="#为客户端签发证书" class="headerlink" title="为客户端签发证书"></a>为客户端签发证书</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -new -newkey rsa:4096 -nodes -keyout clientBob.key -out clientBob.csr<br></code></pre></td></tr></table></figure><p>在索要基本信息的环节中，指定 Commen Name 为 bob。设定私钥密码（challenge password）为 abcdef。如此私钥和 CSR 生成完毕。</p><p>然后签发证书。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl x509 -req -CA rootCA.crt -CAkey rootCA.key -in clientBob.csr -out clientBob.crt -days 365 -CAcreateserial<br></code></pre></td></tr></table></figure><p>将证书以及私钥打包为一个 pkcs12 的 keystore</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl pkcs12 -export -out clientBob.p12 -name &quot;clientBob&quot; -inkey clientBob.key -in clientBob.crt<br></code></pre></td></tr></table></figure><p>此时会要求你输入密码，这个密码是这个 keystore 的，而不是这个私钥的。我们仍然使用 abcedf 作为密码。</p><p>然后使用 keytool 转换为易于 Java 处理的 JKS 的 keystore</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">keytool -importkeystore -srckeystore clientBob.p12 -srcstoretype pkcs12 -destkeystore clientBob.jks -deststoretype pkcs12  -deststorepass abcdef -srcstorepass abcdef<br></code></pre></td></tr></table></figure><p>上述命令运行时的 JDK 环境是 17，keytool 是 JDK 中的工具，因此非 JDK 17 环境，或解析这个生成的 keystore 文件的 java 程序的 JDK 版本低于 17 都可能造成问题。如果上述命令在你的电脑上直接无法运行，可将 -deststoretype pkcs12 改为 -deststoretype jks。 pkcs12 是最新的 keystore 组装策略，而 jks 则是老版本了，老 JDK 也该支持。</p><p>将这一步中得到的私钥 clientBob.key，clientBob.jks 以及 clientBob.cer 从虚拟机中转存到 Windows PC 以待之后使用。</p><h2 id="为服务端程序设置要求验证客户端身份"><a href="#为服务端程序设置要求验证客户端身份" class="headerlink" title="为服务端程序设置要求验证客户端身份"></a>为服务端程序设置要求验证客户端身份</h2><p>Spring Boot 程序开启 SSL 只代表着它会将自己的证书发出去让别人确认它的身份，而不代表着它也会验证别人的身份。</p><p>开启 Mutual SSL 意味着 Spring Boot 会要求客户端发来证书的信息并加以解析。要实现这一点，需要引入 <code>spring security</code> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>并配置 Spring Security 开启验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Profile(&quot;server&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;server.ssl.valid-commonname&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; validCommonNameList;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title function_">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        http.authorizeRequests()<br>                .anyRequest()<br>                .authenticated()<br>                .and()<br>                .x509()<br>                .subjectPrincipalRegex(<span class="hljs-string">&quot;CN=(.*?)(?:,|$)&quot;</span>)<br>                .userDetailsService(userDetailsService());<br>        <span class="hljs-keyword">return</span> http.build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> UserDetailsService <span class="hljs-title function_">userDetailsService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDetailsService</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> UserDetails <span class="hljs-title function_">loadUserByUsername</span><span class="hljs-params">(String username)</span> &#123;<br>                log.info(<span class="hljs-string">&quot;common name = &#123;&#125;&quot;</span>, username);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValidCert</span>(username, CollectionUtils.contains(validCommonNameList.listIterator(), username));<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配套的 <code>UserDetails</code> 实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValidCert</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDetails</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String commonName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> isEnabled;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ValidCert</span><span class="hljs-params">(String commonName, <span class="hljs-type">boolean</span> isEnabled)</span> &#123;<br>        <span class="hljs-built_in">this</span>.commonName = commonName;<br>        <span class="hljs-built_in">this</span>.isEnabled = isEnabled;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Collection&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;<br>        <span class="hljs-keyword">return</span> Collections.emptyList();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPassword</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getCommonName();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAccountNonExpired</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAccountNonLocked</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCredentialsNonExpired</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEnabled</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.isEnabled;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过在配置文件中指定 <code>server.ssl.valid-commonname</code> 的值为 bob，实现只有客户端使用 commen name 为 bob 的证书与这个 Spring Boot 建立 SSL 连接才有可能被接受，否则都会拒绝。</p><h2 id="服务端信任-Self-signed-CA"><a href="#服务端信任-Self-signed-CA" class="headerlink" title="服务端信任 Self-signed CA"></a>服务端信任 Self-signed CA</h2><p>现在，我们需要配置 Self-signed CA 是这个 Spring Boot 可以信任的证书。换言之，包含 Self-signed CA 的证书的 Keystore 是 trustKeyStore：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">keytool -import -trustcacerts -noprompt -alias ca -ext san=dns:localhost,ip:127.0.0.1 -file rootCA.crt -keystore truststore.jks<br></code></pre></td></tr></table></figure><p>因此需要借助 JDK 工具 keytool 生成 keystore 文件，以便之后 Spring Boot 读取。</p><p>随后在 Spring Boot 配置文件中指定加载与信任此 keystore 中的证书：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">server.ssl.trust-store</span>=/root/truststore.jks<br><span class="hljs-attr">server.ssl.trust-store-password</span>=<span class="hljs-variable">$&#123;password&#125;</span><br><span class="hljs-attr">server.ssl.client-auth</span>=need<br><br><span class="hljs-attr">server.ssl.valid-commonname</span>=bob<br></code></pre></td></tr></table></figure><p>统合之前让 Spring Boot 程序加载自己的证书（localhost.crt）的配置，现在 application-server.properties 中的所有配置如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">server.ssl.key-store</span>=/root/localhost.p12<br><span class="hljs-attr">server.ssl.key-store-password</span>=bob<br><span class="hljs-attr">server.ssl.key-alias</span>=localhost<br><span class="hljs-attr">server.ssl.key-password</span>=bob<br><span class="hljs-attr">server.ssl.enabled</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-number">8443</span><br><br><span class="hljs-attr">server.ssl.trust-store</span>=/root/truststore.jks<br><span class="hljs-attr">server.ssl.trust-store-password</span>=<span class="hljs-variable">$&#123;password&#125;</span><br><span class="hljs-attr">server.ssl.client-auth</span>=need<br><span class="hljs-attr">server.ssl.valid-commonname</span>=bob<br><br><span class="hljs-attr">logging.level.org.springframework.security</span>=DEBUG<br></code></pre></td></tr></table></figure><p>将程序打包为可执行的 jar 文件后存入虚拟机，调用 <code>java -jar -Dspring.profiles.active=server xxx.jar</code> 使得程序运行。</p><h2 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h2><p>在 Postman 的 Settings 中的 Certificates 中为访问特定 host 与端口设定访问时使用的证书与证书私钥文件（以及私钥的密码）后，Postman 在发出请求给那个 host 与端口时会携带上这个证书的信息。</p><p><img src="https://s2.loli.net/2023/05/29/Sl5eAn87VBrQhga.png" alt="postman_client_using_cert.png"></p><p>此时 <code>https://192.168.19.128:8443/</code> 才会得到期待的返回结果，如果不进行此设置，应道返回 401 Unauthorized 错误。</p><h2 id="使用-Spring-中的-RestTemplate-访问服务端"><a href="#使用-Spring-中的-RestTemplate-访问服务端" class="headerlink" title="使用 Spring 中的 RestTemplate 访问服务端"></a>使用 Spring 中的 RestTemplate 访问服务端</h2><p>本地运行另一个 Spring 程序，这个程序在收到请求后会调用 RestTemplate 将请求发给虚拟机上的服务，将得到的请求结果原样返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Profile(&quot;client&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RequestMapping(&quot;/client&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientController</span> &#123;<br><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRestTemplate</span><span class="hljs-params">(RestTemplate restTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.restTemplate = restTemplate;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">client</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(<span class="hljs-string">&quot;https://192.168.19.128:8443/&quot;</span>, String.class);<br>        <span class="hljs-keyword">return</span> responseEntity.getBody();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果只是简单的创建一个 <code>RestTemplate</code> 的实例，它是不能够建立起 SSL 连接，也自然无法建立 HTTPS 连接，调用 HTTPS 资源的。但 Spring 在设计 <code>RestTemplate</code> 还有一个接受 <code>ClientHttpRequestFactory</code> 接口的实例的构造方法。并且为这个接口提供了对应 Apache Http Components v4 和 OkHttp v3 的适配器类 <code>HttpComponentsClientHttpRequestFactory</code> 和 <code>OkHttp3ClientHttpRequestFactory</code>，这使得我们可以借助 Apache Http Components 或 OkHttp 这样成熟的开源 Http Client 库。</p><p>首先 Spring 内置的 Apache Http Core 已经不足用了，需要引入 Apache Http Components:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>显然在配置可以创建 SSL 连接的请求工厂的过程中，需要指定发起者使用的 KeyStore 以及 KeyStore 和使用的私钥的密码。</p><p>先将『为客户端签发证书』一章中得到的 clientBob.jks 保存到正在编写的客户端程序的 resouces 文件夹下。随后在配置文件中指定路径和密码。</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">rest.ssl.client</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">bob</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">keyStoreFile</span><span class="hljs-punctuation">:</span> <span class="hljs-string">classpath:clientBob.jks</span><br>    <span class="hljs-attribute">keyStorePwd</span><span class="hljs-punctuation">:</span> <span class="hljs-string">abcdef</span><br>    <span class="hljs-attribute">privateKeyPwd</span><span class="hljs-punctuation">:</span> <span class="hljs-string">abcdef</span><br></code></pre></td></tr></table></figure><p>为这个配置编写一个 POJO 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientKeyStoreInfo</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Resource keyStoreFile;<br>    <span class="hljs-keyword">private</span> String keyStorePwd;<br>    <span class="hljs-keyword">private</span> String privateKeyPwd;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setKeyStoreFile</span><span class="hljs-params">(Resource keyStoreFile)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.keyStoreFile == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.keyStoreFile = keyStoreFile;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setKeyStorePwd</span><span class="hljs-params">(String keyStorePwd)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.keyStorePwd == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.keyStorePwd = keyStorePwd;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrivateKeyPwd</span><span class="hljs-params">(String privateKeyPwd)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.privateKeyPwd == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.privateKeyPwd = privateKeyPwd;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Profile(&quot;client&quot;)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Qualifier(&quot;clientBob&quot;)</span><br>    <span class="hljs-meta">@ConfigurationProperties(&quot;rest.ssl.client.bob&quot;)</span><br>    <span class="hljs-keyword">public</span> ClientKeyStoreInfo <span class="hljs-title function_">clientBob</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientKeyStoreInfo</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ClientKeyStoreInfo</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> clientBob();<br>        log.info(<span class="hljs-string">&quot;client: &#123;&#125;&quot;</span>, client);<br><br>        <span class="hljs-comment">//SSL Context 是 JDK 中的东西</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">SSLContext</span> <span class="hljs-variable">sslContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SSLContextBuilder</span>()<br>                <span class="hljs-comment">//.setKeyStoreType(&quot;jks&quot;) </span><br>                .setKeyStoreType(<span class="hljs-string">&quot;pkcs12&quot;</span>) <span class="hljs-comment">// 说明 keystore 的组织格式</span><br>                .loadKeyMaterial(client.getKeyStoreFile().getURL(), <span class="hljs-comment">//loadKeyMaterial 声明了建立 SSL 连接时我方作为发起者所用到的 keystore 的信息</span><br>                        client.getKeyStorePwd().toCharArray(),<br>                        client.getPrivateKeyPwd().toCharArray())<br>                .loadTrustMaterial((TrustStrategy) (chain, authType) -&gt; <span class="hljs-literal">true</span>) <span class="hljs-comment">// loadTrustMaterial 需要我们提供一个根据对方提供的证书，判断对方是否可信的处理器。此处我们简单地无论如何都返回 true。</span><br>                .build();<br><br>        <span class="hljs-comment">// SSLConnectionSocketFactory 和 CloseableHttpClient 都是 Apache HTTP Components 中的东西，基于 JDK 的 SSLContext 做了进一步封装。</span><br>        <span class="hljs-type">SSLConnectionSocketFactory</span> <span class="hljs-variable">sslConFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SSLConnectionSocketFactory</span>(sslContext);<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> HttpClients.custom()<br>                .setSSLSocketFactory(sslConFactory)<br>                .build();<br><br>        <span class="hljs-comment">// RestTemplate 提供一个接收 ClientHttpRequestFactory 的实例的 HttpReqeust 工厂并提供 HttpComponentsClientHttpRequestFactory 作为 Apache HTTP Components 的适配器类，以方便我们快速利用 Apache HTTP Components</span><br>        <span class="hljs-type">ClientHttpRequestFactory</span> <span class="hljs-variable">requestFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpComponentsClientHttpRequestFactory</span>(httpClient);<br><br>        <span class="hljs-type">RestTemplate</span> <span class="hljs-variable">restTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>(requestFactory);<br><br>        <span class="hljs-keyword">return</span> restTemplate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置类中的细节请见代码中的注解部分。</p><p>至此，我们再添加一个 <code>/client</code> 接口，Postman 调用这个接口时，Spring 程序会调用 RestTemplate 去调用下一个 Linux 虚拟机中的服务端并将得到的结果返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Profile(&quot;client&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RequestMapping(&quot;/client&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientController</span> &#123;<br><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRestTemplate</span><span class="hljs-params">(RestTemplate restTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.restTemplate = restTemplate;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">client</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(<span class="hljs-string">&quot;https://192.168.19.128:8443/&quot;</span>, String.class);<br>        <span class="hljs-keyword">return</span> responseEntity.getBody();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>全文完。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SSL,计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Debian安装软件</title>
    <link href="/2023/01/28/%E5%9C%A8Debian%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/"/>
    <url>/2023/01/28/%E5%9C%A8Debian%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h1><p><code>dpkg -i ...</code> 用于 .deb 结尾的文件。.deb 结尾的文件通常是一个软件的安装包，可以借此直接安装软件。</p><p><code>dpkg -l</code> 展示本地已安装的所有软件。与 <code>| grep ...</code> 结合可以查看本地已安装哪些包含 … 的软件。</p><p><code>apt-cache policy ...</code> 可以查看软件在当前 apt 源中的可用版本Version table 属性）。如果所查询的软件已经安装在系统上，则 Installed 属性会指示安装在系统上的属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@debian11-cicd:~<span class="hljs-comment"># apt-cache policy nginx</span><br>nginx:<br>  已安装：(无)<br>  候选： 1.18.0-6.1+deb11u3<br>  版本列表：<br>     1.18.0-6.1+deb11u3 500<br>        500 http://mirrors.huaweicloud.com/debian bullseye/main amd64 Packages<br>        500 http://security.debian.org/debian-security bullseye-security/main amd64 Packages<br></code></pre></td></tr></table></figure><p><code>apt-get install ...</code> 时的默认版本是 <code>apt-cache policy</code> 查询的结果的 Candidate 属性）以及当前是否安装（Installed 属性）。</p><p><code>apt-cache madison ...</code> 可以查看软件在当前 apt 源中的所有版本以及如果使用这个版本的话将使用什么源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@VM-133-145-debian:~/download<span class="hljs-comment"># apt-cache madison erlang</span><br>    erlang | 1:19.2.1+dfsg-2+deb9u3 | http://mirrors.tencentyun.com/debian stretch/main amd64 Packages<br>    erlang | 1:19.2.1+dfsg-2+deb9u3 | http://mirrors.tencentyun.com/debian stretch/main i386 Packages<br>    erlang | 1:19.2.1+dfsg-2+deb9u1 | http://mirrors.tencentyun.com/debian-security stretch/updates/main amd64 Packages<br>    erlang | 1:19.2.1+dfsg-2+deb9u1 | http://mirrors.tencentyun.com/debian-security stretch/updates/main i386 Packages<br>    erlang | 1:19.2.1+dfsg-2+deb9u3 | http://mirrors.tencentyun.com/debian stretch/main Sources<br>    erlang | 1:19.2.1+dfsg-2+deb9u1 | http://mirrors.tencentyun.com/debian-security stretch/updates/main Sources<br>N: Ignoring file <span class="hljs-string">&#x27;rabbitmq_rabbitmq-server&#x27;</span> <span class="hljs-keyword">in</span> directory <span class="hljs-string">&#x27;/etc/apt/sources.list.d/&#x27;</span> as it has no filename extension<br>N: Ignoring file <span class="hljs-string">&#x27;bintray.erlang&#x27;</span> <span class="hljs-keyword">in</span> directory <span class="hljs-string">&#x27;/etc/apt/sources.list.d/&#x27;</span> as it has an invalid filename extension<br></code></pre></td></tr></table></figure><p><code>apt-get install ...=version</code> 可以在软件名后增补 <code>=version</code> 来强制指定安装软件的版本。这里的 version 只能是 apt-cache policy 或 apt-cache madison 中查出来的可用版本号。</p><p>关于软件卸载：</p><p><code>apt-get purge</code> 或 <code>apt-get --purge remove</code> 都是删除指定软件且不保留配置文件。</p><p><code>apt-get autoremove</code> 移除系统当前不再需要的软件。会出现这种软件，一般是在安装A软件时，需要B软件作为基础库，随后A软件被移除了。</p><p><code>apt-get remove</code> 删除已安装的软件包但保留配置文件。</p><p>在删除过程中可能会出现居然需要用户同意安装某个软件的操作。为什么会这样？因为现在被删除的这个软件是其它某个软件的依赖，提示用户允许的要新安装的软件则是替换被删除软件来充当依赖的。</p><p>实际上，这种情况的出现意味着用户执行删除软件的操作是不慎重的。如果要使用的软件B还依赖着软件A，就不应该移除软件A。或者应该先完成对软件B的不使用和移除。</p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>docker 官方提供了如何在 debian 上安装 docker 的方式。<a href="https://docs.docker.com/engine/install/debian/#install-using-the-repository">传送门</a>。</p><p>另外由于众所周知的原因，直接访问境外的 docker 下载源通常会很慢。清华大学镜像站为此提供了镜像服务以及相关的<a href="https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/">安装文档</a>。</p><p>安装好 docker 之后需要使用 docker hub 下载和安装 docker image，对于国内服务器又需要配置 docker hub 的镜像。这里建议买的云服务器是谁，配谁的镜像。我用的是腾讯云，参考腾讯云的<a href="https://cloud.tencent.com/document/product/1141/63910">快速入门文档</a>。</p><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="从-apt-get-安装-nginx"><a href="#从-apt-get-安装-nginx" class="headerlink" title="从 apt-get 安装 nginx"></a>从 apt-get 安装 nginx</h2><p><code>sudo apt install nginx</code></p><p>安装完成后，nginx 服务自动被注册在 systemctl 中。</p><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>从 <a href="http://nginx.org/">Nginx 官网</a> 的下载页面中选择 Stable version 的不带 windows 的那个下载到云主机中进行手动编译安装。</p><p>2022年12月13日，nginx 已经发布了稳定的 1.22 版本，而在 debian 11 上使用 ·apt-get cache policy nginx· 得到的 nginx 版本还在 1.18.x，所以我选择自己装。</p><p>下载源码后需要编译安装，故需要阅读官方文档中 <a href="http://nginx.org/en/docs/configure.html">Building nginx from Sources</a>。其安装方法简单来说就是解压缩下载到的源码压缩包后进入其解压后目录（该目录下应当有一个 configure 文件），随后以该目录为工作目录完成后续步骤：</p><p>执行 <code>./configure</code> 命令</p><p>如果只是简单学习使用 Nginx，所以啥配置项都不指定也够用。但如果要带 https 支持的话要带上参数 <code>--with-http_ssl_module</code> 即 <code>./configure --with-http_ssl_module</code>。</p><p>但第一次执行并不能安装成功，遇到缺失 pcre 支持无法支持 http 模块功能的错误：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">./configure: error: <span class="hljs-keyword">the</span> HTTP rewrite module requires <span class="hljs-keyword">the</span> PCRE library.<br>You can either disable <span class="hljs-keyword">the</span> module <span class="hljs-keyword">by</span> <span class="hljs-keyword">using</span> <span class="hljs-comment">--without-http_rewrite_module</span><br>option, <span class="hljs-keyword">or</span> install <span class="hljs-keyword">the</span> PCRE library <span class="hljs-keyword">into</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">system</span>, <span class="hljs-keyword">or</span> build <span class="hljs-keyword">the</span> PCRE library<br>statically <span class="hljs-built_in">from</span> <span class="hljs-keyword">the</span> source <span class="hljs-keyword">with</span> nginx <span class="hljs-keyword">by</span> <span class="hljs-keyword">using</span> <span class="hljs-comment">--with-pcre=&lt;path&gt; option.</span><br></code></pre></td></tr></table></figure><p>以 pcre debian 为关键词谷歌，得到 apt-get install libpcre3 libpcre3-dev 来安装相关库，解决这一问题。</p><p>但在安装了这些之后仍然不成功，遇到 zlib 库的问题：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">./configure: error: <span class="hljs-keyword">the</span> HTTP gzip module requires <span class="hljs-keyword">the</span> zlib library.<br>You can either disable <span class="hljs-keyword">the</span> module <span class="hljs-keyword">by</span> <span class="hljs-keyword">using</span> <span class="hljs-comment">--without-http_gzip_module</span><br>option, <span class="hljs-keyword">or</span> install <span class="hljs-keyword">the</span> zlib library <span class="hljs-keyword">into</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">system</span>, <span class="hljs-keyword">or</span> build <span class="hljs-keyword">the</span> zlib library<br>statically <span class="hljs-built_in">from</span> <span class="hljs-keyword">the</span> source <span class="hljs-keyword">with</span> nginx <span class="hljs-keyword">by</span> <span class="hljs-keyword">using</span> <span class="hljs-comment">--with-zlib=&lt;path&gt; option.</span><br></code></pre></td></tr></table></figure><p>以 zlib debian 为关键词谷歌，得到 sudo apt install zlib1g-dev 来安装 zlib 库，解决这一问题。</p><p>第三次执行 .&#x2F;configure 终于成功，最后输出：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Configuration summary<br>  + <span class="hljs-keyword">using</span> <span class="hljs-keyword">system</span> PCRE library<br>  + OpenSSL library is <span class="hljs-keyword">not</span> used<br>  + <span class="hljs-keyword">using</span> <span class="hljs-keyword">system</span> zlib library<br><br>  nginx path prefix: <span class="hljs-string">&quot;/usr/local/nginx&quot;</span><br>  nginx binary <span class="hljs-built_in">file</span>: <span class="hljs-string">&quot;/usr/local/nginx/sbin/nginx&quot;</span><br>  nginx modules path: <span class="hljs-string">&quot;/usr/local/nginx/modules&quot;</span><br>  nginx configuration prefix: <span class="hljs-string">&quot;/usr/local/nginx/conf&quot;</span><br>  nginx configuration <span class="hljs-built_in">file</span>: <span class="hljs-string">&quot;/usr/local/nginx/conf/nginx.conf&quot;</span><br>  nginx pid <span class="hljs-built_in">file</span>: <span class="hljs-string">&quot;/usr/local/nginx/logs/nginx.pid&quot;</span><br>  nginx error <span class="hljs-built_in">log</span> <span class="hljs-built_in">file</span>: <span class="hljs-string">&quot;/usr/local/nginx/logs/error.log&quot;</span><br>  nginx <span class="hljs-keyword">http</span> access <span class="hljs-built_in">log</span> <span class="hljs-built_in">file</span>: <span class="hljs-string">&quot;/usr/local/nginx/logs/access.log&quot;</span><br>  nginx <span class="hljs-keyword">http</span> client request body temporary <span class="hljs-built_in">files</span>: <span class="hljs-string">&quot;client_body_temp&quot;</span><br>  nginx <span class="hljs-keyword">http</span> proxy temporary <span class="hljs-built_in">files</span>: <span class="hljs-string">&quot;proxy_temp&quot;</span><br>  nginx <span class="hljs-keyword">http</span> fastcgi temporary <span class="hljs-built_in">files</span>: <span class="hljs-string">&quot;fastcgi_temp&quot;</span><br>  nginx <span class="hljs-keyword">http</span> uwsgi temporary <span class="hljs-built_in">files</span>: <span class="hljs-string">&quot;uwsgi_temp&quot;</span><br>  nginx <span class="hljs-keyword">http</span> scgi temporary <span class="hljs-built_in">files</span>: <span class="hljs-string">&quot;scgi_temp&quot;</span><br></code></pre></td></tr></table></figure><p>之后再输入 make 指令即可完成安装。</p><h3 id="交付-systemctl"><a href="#交付-systemctl" class="headerlink" title="交付 systemctl"></a>交付 systemctl</h3><p>参考<a href="https://xaiversun.gitee.io/blog/2021/05/11/0xC/#%E5%B0%86%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%89%98%E7%AE%A1-systemctl">将编译安装的软件托管 systemctl</a>一节。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><code>nginx -t</code> 可以检测配置文件是否存在问题。</p><p>没有问题时会有如下输出：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">nginx: the configuration <span class="hljs-keyword">file</span> /etc/nginx/nginx.<span class="hljs-keyword">conf</span> <span class="hljs-keyword">syntax</span> <span class="hljs-keyword">is</span> ok<br>nginx: configuration <span class="hljs-keyword">file</span> /etc/nginx/nginx.<span class="hljs-keyword">conf</span> test <span class="hljs-keyword">is</span> successful<br></code></pre></td></tr></table></figure><p>输出中也透露了配置文件的具体路径：<code>/etc/nginx/nginx.conf</code></p><h2 id="网站启用-https"><a href="#网站启用-https" class="headerlink" title="网站启用 https"></a>网站启用 https</h2><p>nginx 提供了 <a href="http://nginx.org/en/docs/http/configuring_https_servers.html">Configuring HTTPS servers</a> 文档可以参考。</p><p>同时随着 ACME2 技术的普及，SSL 证书的供应商可能会给出基于 ACME 技术部署 nginx https 证书的脚本。比如<a href="https://blog.freessl.cn/acme-quick-start/">ACME v2证书自动化快速入门</a>一文。</p><h1 id="MYSQL-5-7"><a href="#MYSQL-5-7" class="headerlink" title="MYSQL 5.7"></a>MYSQL 5.7</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>依据MySQL 官方的<a href="https://dev.mysql.com/doc/refman/5.7/en/linux-installation-debian.html">安装文档</a>：</p><p>首先是下载一个 .deb 文件到云服务器中，随后对那个文件执行 <code>dpkg -i path_of_the_deb_file</code>，目的是将包含 MYSQL 5.7 的安装包的 APT 仓库加入到云服务器的 APT 仓库列表中。</p><p>但是，这里使用 .deb 文件添加 MySQL 5.7 的官方安装源，会让 apt 从 MySQL 官方下载 MySQL，即可能出现之前安装 Docker 时下载速度比较慢的问题。所以还是需要使用<a href="https://mirrors.tuna.tsinghua.edu.cn/help/mysql/">清华大学镜像站</a>。</p><p>在安装时遇到了 gnupg is not installed 的问题：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">root</span>@VM-<span class="hljs-number">4</span>-<span class="hljs-number">3</span>-debian:~/downloads# dpkg -i mysql-apt-config_0.<span class="hljs-number">8</span>.<span class="hljs-number">16</span>-<span class="hljs-number">1</span>_all.deb<br><span class="hljs-attribute">dpkg</span>: regarding mysql-apt-config_0.<span class="hljs-number">8</span>.<span class="hljs-number">16</span>-<span class="hljs-number">1</span>_all.deb containing mysql-apt-config, pre-dependency problem:<br> <span class="hljs-attribute">mysql</span>-apt-config pre-depends <span class="hljs-literal">on</span> gnupg<br>  <span class="hljs-attribute">gnupg</span> is not installed.<br><br><span class="hljs-attribute">dpkg</span>: error processing archive mysql-apt-config_0.<span class="hljs-number">8</span>.<span class="hljs-number">16</span>-<span class="hljs-number">1</span>_all.deb (--install):<br> <span class="hljs-attribute">pre</span>-dependency problem - not installing mysql-apt-config<br><span class="hljs-attribute">Errors</span> were encountered while processing:<br> <span class="hljs-attribute">mysql</span>-apt-config_0.<span class="hljs-number">8</span>.<span class="hljs-number">16</span>-<span class="hljs-number">1</span>_all.deb<br></code></pre></td></tr></table></figure><p>解决方法就是把它装了：<code>apt install gnupg</code>。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">apt-<span class="hljs-keyword">get</span> install mysql-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>如果使用清华镜像站的源，本应使用 <code>deb https://mirrors.tuna.tsinghua.edu.cn/mysql/apt/debian stretch mysql-5.6 mysql-5.7 mysql-8.0 mysql-tools</code> 填入 <code>/etc/apt/sources.list.d/mysql-community.list</code> 文件，但我只想安装 MySQL 5.7，所以删减为 <code>deb https://mirrors.tuna.tsinghua.edu.cn/mysql/apt/debian stretch mysql-5.7 mysql-tools</code>。</p><p>帮助文档中的 <code>/etc/apt/sources.list.d/mysql-community.list</code> 要是不存在，就新建一个写。此后还需要 <code>apt-get update</code> 让 apt 更新使这一修改生效，然后再执行 “Installing MySQL with APT” 章节的内容。</p><p>如果 MySQL 5.7 的安装是配置云服务器的第一步，那么很有可能无法使用 https 协议的清华镜像源。这件事会暴露在编辑 mysql-community.list 文件后的 apt-get update 后，错误信息如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">E: The <span class="hljs-keyword">method</span> <span class="hljs-title function_">driver</span> /<span class="hljs-title function_">usr</span>/<span class="hljs-title function_">lib</span>/<span class="hljs-title function_">apt</span>/<span class="hljs-title function_">methods</span>/<span class="hljs-title function_">https</span> <span class="hljs-title function_">could</span> <span class="hljs-title function_">not</span> <span class="hljs-title function_">be</span> <span class="hljs-title function_">found</span>.<br><span class="hljs-title function_">N</span>: <span class="hljs-keyword">Is</span> the package apt-transport-https installed?<br>E: Failed <span class="hljs-keyword">to</span> fetch https:<span class="hljs-comment">//mirrors.cloud.tencent.com/mysql/apt/debian/dists/stretch/InRelease  </span><br>E: Some <span class="hljs-keyword">index</span> files failed <span class="hljs-keyword">to</span> download. They have been ignored, <span class="hljs-keyword">or</span> <span class="hljs-keyword">old</span> ones used instead.<br></code></pre></td></tr></table></figure><p>错误提示中的第二行其实已经给出了解决方案。使用 <code>apt install apt-transport-https</code> 将缺失的包安装。再度执行 <code>apt update</code>，不再报错。</p><p>现在，使用 <code>apt-cache policy mysql-server</code> 确定要安装的 mysql 版本为 5.7：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@VM-4-3-debian:~/downloads<span class="hljs-comment"># apt-cache policy mysql-server</span><br>mysql-server:<br>  Installed: (none)<br>  Candidate: 5.7.32-1debian10<br>  Version table:<br>     5.7.32-1debian10 500<br>        500 https://mirrors.cloud.tencent.com/mysql/apt/debian buster/mysql-5.7 amd64 Packages<br>        500 http://repo.mysql.com/apt/debian buster/mysql-5.7 amd64 Packages<br></code></pre></td></tr></table></figure><p>确认过后可以输入执行 <code>apt-get install mysql-server</code> 开始安装。</p><h2 id="允许被远程接入"><a href="#允许被远程接入" class="headerlink" title="允许被远程接入"></a>允许被远程接入</h2><p>MySQL 5.7 默认不允许远程主机接入。搜索 mysql 5.7 allow remote access，找到 StackOverflow 上的一个相关问题 <a href="https://stackoverflow.com/questions/14779104/how-to-allow-remote-connection-to-mysql">How to allow remote connection to mysql</a>。</p><blockquote><p>What is disabled by default is remote root access. If you want to enable that, run this SQL command locally:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> *.* <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;password&#x27;</span> <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">OPTION</span>;<br> FLUSH <span class="hljs-keyword">PRIVILEGES</span>;<br></code></pre></td></tr></table></figure><p>And then find the following line and comment it out in your my.cnf file, which usually lives on &#x2F;etc&#x2F;mysql&#x2F;my.cnf on Unix&#x2F;OSX systems. In some cases the location for the file is &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf).</p><p>If it’s a Windows system, you can find it in the MySQL installation directory, usually something like C:\Program Files\MySQL\MySQL Server 5.5\ and the filename will be my.ini.</p><p>Change line</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">bind-address</span> <span class="hljs-operator">=</span> <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br></code></pre></td></tr></table></figure><p>to</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">#bind-address = 127.0.0.1</span><br></code></pre></td></tr></table></figure><p>And restart the MySQL server (Unix&#x2F;OSX, and Windows) for the changes to take effect.</p></blockquote><p>回答前半部分照做即可，只有代码中的 ‘password’ 里的 password 要换成真实的 mysql 的 root 用户的密码。</p><p>但后半段，并不存在 <code>/etc/mysql/my.cnf</code> 这一文件，即便我自己新建然后添加 <code>#bind-address = 127.0.0.1</code> 的内容也仍然无用。但思路是明确的，我们要找到 mysql 的有效配置文件。</p><p>翻看官方文档 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html">5.1.2 Server Configuration Defaults</a></p><blockquote><p>For non-Windows platforms, no default option file is created during either the server installation or the data directory initialization process. Create your option file by following the instructions given in <a href="https://dev.mysql.com/doc/refman/5.7/en/option-files.html">Section 4.2.2.2</a>, “Using Option Files”. Without an option file, the server just starts with its default settings—see Section 5.1.2, “Server Configuration Defaults” on how to check those settings.</p></blockquote><p><a href="https://dev.mysql.com/doc/refman/5.7/en/option-files.html">Section 4.2.2.2</a></p><blockquote><p>Most MySQL programs can read startup options from option files (sometimes called configuration files). Option files provide a convenient way to specify commonly used options so that they need not be entered on the command line each time you run a program.</p><p>To determine whether a program reads option files, invoke it with the –help option. (For mysqld, use –verbose and –help.) If the program reads option files, <strong>the help message indicates which files it looks for and which option groups it recognizes.</strong></p></blockquote><p>所以在主机上输入使用 <code>mysqld --help</code> 命令。得到：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs smali">mysqld  Ver 8.0.21 for Linux on x86_64 (MySQL Community Server - GPL)<br>Copyright (c) 2000, 2020, Oracle<span class="hljs-built_in"> and/or </span>its affiliates. All rights reserved.<br><br>Oracle is a registered trademark of Oracle Corporation<span class="hljs-built_in"> and/or </span>its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br><br>Starts the MySQL database server.<br><br>Usage: mysqld [OPTIONS]<br><br>For more help options (several pages), use mysqld --verbose --help.<br></code></pre></td></tr></table></figure><p>由于</p><blockquote><p>For more help options (several pages), use mysqld –verbose –help.</p></blockquote><p>执行 <code>mysqld --verbose --help &gt; ~/mysql-config.txt</code>，阅读时发现其中说</p><blockquote><p>Default options are read from the following files in the given order:<br>&#x2F;etc&#x2F;my.cnf &#x2F;etc&#x2F;mysql&#x2F;my.cnf ~&#x2F;.my.cnf</p></blockquote><p>其中 <code>·~/.my.cnf</code> 和 <code>/etc/my.cnf</code> 均不存在，而 <code>/etc/mysql/my.cnf</code> 存在且包含如下两行：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">!includedir <span class="hljs-regexp">/etc/my</span>sql<span class="hljs-regexp">/conf.d/</span><br>!includedir <span class="hljs-regexp">/etc/my</span>sql<span class="hljs-regexp">/mysql.conf.d/</span><br></code></pre></td></tr></table></figure><p>在 &#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F; 下有一个 mysql.cnf 文件，不过其中啥也没有。</p><p>而 &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F; 下有一个 mysqld.cnf 文件，其中有东西：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#/etc/mysql/mysql.conf.d/mysqld.cnf</span><br>[mysqld]<br>pid-file    = /var/run/mysqld/mysqld.pid<br>socket        = /var/run/mysqld/mysqld.sock<br>datadir        = /var/lib/mysql<br>log-error    = /var/log/mysql/error.log<br><span class="hljs-comment"># By default we only accept connections from localhost</span><br>bind-address    = 127.0.0.1<br><span class="hljs-comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br>symbolic-links=0<br></code></pre></td></tr></table></figure><p>有 stackoverflow 回答里说的要注释的东西了，把它注释掉。</p><p>然后 systemctl restart mysql 。这之后就可以连接了。</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><a href="https://redis.io/docs/getting-started/installation/install-redis-on-linux/">Redis官方安装文档</a></p><h1 id="Java-与-Maven"><a href="#Java-与-Maven" class="headerlink" title="Java 与 Maven"></a>Java 与 Maven</h1><h2 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h2><p>在 <a href="https://www.injdk.cn/">Java I tell you</a> 中选择合适的 jdk 版本并下载到本地进行安装。此处我选择 Temurin 版本 （Adoptopenjdk自2020年7月交给Eclipse基金会，后改名Temurin）以及 jdk 17，<a href="https://d6.injdk.cn/openjdk/adoptopenjdk/17/OpenJDK17U-jdk_x64_linux_hotspot_17.0.1_12.tar.gz">linux64.tar.gz</a> 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> ~/download<br><span class="hljs-built_in">cd</span> ~/download<br>wget https://d6.injdk.cn/openjdk/adoptopenjdk/17/<br>OpenJDK17U-jdk_x64_linux_hotspot_17.0.1_12.tar.gz<br><span class="hljs-built_in">mkdir</span> /usr/local/temurin/<br>tar -xzf OpenJDK17U-jdk_x64_linux_hotspot_17.0.1_12.tar.gz -C /usr/local/temurin/<br><span class="hljs-built_in">cd</span> /usr/local/temurin/<br>root@debian11-cicd:/usr/local/temurin<span class="hljs-comment"># ls</span><br>jdk-17.0.1+12<br></code></pre></td></tr></table></figure><p>然后编辑 <code>/etc/profile</code>，在最后新增如下几行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">JAVA_HOME</span>=/usr/local/temurin/jdk-17.0.1+12<br><span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$JAVA_HOME/bin<br></code></pre></td></tr></table></figure><p>执行 <code>source /etc/profile</code></p><p>通过 <code>java --version</code> 验证，应该得到如下结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">root</span>@debian11-cicd:/usr/local/temurin# java --version<br><span class="hljs-attribute">openjdk</span> <span class="hljs-number">17</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> <span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">19</span><br><span class="hljs-attribute">OpenJDK</span> Runtime Environment Temurin-<span class="hljs-number">17</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>+<span class="hljs-number">12</span> (build <span class="hljs-number">17</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>+<span class="hljs-number">12</span>)<br><span class="hljs-attribute">OpenJDK</span> <span class="hljs-number">64</span>-Bit Server VM Temurin-<span class="hljs-number">17</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>+<span class="hljs-number">12</span> (build <span class="hljs-number">17</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>+<span class="hljs-number">12</span>, mixed mode, sharing)<br></code></pre></td></tr></table></figure><p>maven 的安装与之类似。从<a href="https://maven.apache.org/download.cgi">官网</a>获取最新包的路径，解压缩，配置环境变量。</p><p>选 Binary tar.gz archive 是 maven 程序编译后的产品。Source tar.gz archive 是 maven 的源代码还没有编译过，怎么用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/download<br>wget https://dlcdn.apache.org/maven/maven-3/3.8.7/binaries/apache-maven-3.8.7-bin.tar.gz<br>tar -xzf apache-maven-3.8.7-bin.tar.gz -C /usr/local/<br></code></pre></td></tr></table></figure><p>同样进行环境变量的配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">MAVEN_HOME</span>=/usr/local/apache-maven-3.8.7<br><span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$MAVEN_HOME/bin<br></code></pre></td></tr></table></figure><h2 id="配置-maven-镜像"><a href="#配置-maven-镜像" class="headerlink" title="配置 maven 镜像"></a>配置 maven 镜像</h2><p>在 maven 的配置文件 <code>$MAVEN_HOME/conf/settings.xml</code> 中加入<a href="https://developer.aliyun.com/mirror/maven/">阿里云的 maven 镜像站</a>的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>aliyunmaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>阿里云公共仓库<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="NodeJs-和-npm"><a href="#NodeJs-和-npm" class="headerlink" title="NodeJs 和 npm"></a>NodeJs 和 npm</h1><h2 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h2><p><a href="https://nodejs.org/en/download/">Node.js 官网</a></p><p><a href="https://github.com/nodejs/help/wiki/Installation">Node.js Linux 安装指南</a></p><p>但我们不从官网下载，而是从<a href="https://nodejs.org/dist/latest/">清华的镜像站</a>下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/download<br>wget https://nodejs.org/dist/latest/node-v19.5.0-linux-x64.tar.xz<br></code></pre></td></tr></table></figure><p>随后按照文档操作即可</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir -p <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/lib/</span>nodejs<br>tar -xJvf node-v19.<span class="hljs-number">5.0</span>-linux-x64.tar.xz -C <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/lib/</span>nodejs<br></code></pre></td></tr></table></figure><p>文档说在 <code>~/.profile</code> 里设置环境变量，保守了。直接在 <code>/etc/profile</code> 最末继续插入就好。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">NODE_JS_HOME</span>=/usr/local/lib/nodejs/node-v19.5.0-linux-x64<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$NODE_JS_HOME</span>/bin:$PATH<br></code></pre></td></tr></table></figure><h2 id="npm-配置镜像"><a href="#npm-配置镜像" class="headerlink" title="npm 配置镜像"></a>npm 配置镜像</h2><p><a href="https://developer.aliyun.com/mirror/NPM?spm=a2c6h.13651102.0.0.30da1b11l49Cj4">阿里云 npm 镜像站</a></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm config set registry https:<span class="hljs-comment">//registry.npmmirror.com/</span><br>npm config get registry<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux运维</title>
    <link href="/2023/01/28/Linux%E8%BF%90%E7%BB%B4/"/>
    <url>/2023/01/28/Linux%E8%BF%90%E7%BB%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="指定全局别名-alias-x2F-环境变量"><a href="#指定全局别名-alias-x2F-环境变量" class="headerlink" title="指定全局别名(alias)&#x2F;环境变量"></a>指定全局别名(alias)&#x2F;环境变量</h1><h2 id="为-Java-11-配置-java-命令"><a href="#为-Java-11-配置-java-命令" class="headerlink" title="为 Java 11 配置 java 命令"></a>为 Java 11 配置 java 命令</h2><p>可以从<a href="https://www.injdk.cn/">JDK国内镜像站</a>下载对应的JDK编译后压缩包，解压缩到合适位置。一般是&#x2F;usr文件夹下。我放在了&#x2F;user&#x2F;java&#x2F;jdk-11下。</p><p>之后开始配置环境变量。</p><p>首先 <code>vim /etc/profile</code> 对 <code>/etc/profile</code> 进行编辑，这个文件是 Linux 系统下环境变量的大管家。</p><p>在文件最下方加入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">COPYexport JAVA_HOME=/usr/java/jdk-11<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>完成后输入 <code>:wq</code> 退出vim的编辑视图。</p><p>随后 source &#x2F;etc&#x2F;profile 使得修改立刻生效。</p><p>再输入 <code>java -version</code> 应当有如下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">COPYopenjdk version <span class="hljs-string">&quot;11&quot;</span> 2018-09-25<br>OpenJDK Runtime Environment 18.9 (build 11+28)<br>OpenJDK 64-Bit Server VM 18.9 (build 11+28, mixed mode)<br></code></pre></td></tr></table></figure><p>说明安装已经完成。</p><h2 id="同时安装-Java-8"><a href="#同时安装-Java-8" class="headerlink" title="同时安装 Java 8"></a>同时安装 Java 8</h2><p>给 Java 8 的 JDK 使用 java8 的别名去调用，即运行它等于运行 jJava 8 所在目录（下载 Java 8 的压缩包解压后出来的文件夹）的 bin 目录下的 java。</p><p>对应操作：</p><p>在<code>/etc/profile</code>文件中写入一行 <code>alias java11=&#39;/usr/openjdk8/bin/java&#39;</code>，然后在终端中输入并回车<code>source /etc/profile</code></p><h1 id="设置软连接"><a href="#设置软连接" class="headerlink" title="设置软连接"></a>设置软连接</h1><p><code>ln -s 要被链接上的文件（夹）的路径 用来链接到那个文件（夹）的文件</code></p><p>在 nginx 配置自己的 webapp 时有这样一个操作：</p><p>COPYln -s &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;example.com &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;<br>这里 &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;example.com 是被链接的对象</p><p>&#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F; 是链接？并不。因为它是一个目录，而目标却是一个文件。那么此时会在目录下自动生成一个名为 example.com 的文件用于对应目标文件以进行连接。但如果这里就是一个第一个参数就是一个文件，那么这个文件就会成为链接，即便文件名不同。</p><h1 id="Shell-脚本"><a href="#Shell-脚本" class="headerlink" title="Shell 脚本"></a>Shell 脚本</h1><h2 id="用法"><a href="#用法" class="headerlink" title="$用法"></a>$用法</h2><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td>$0</td><td>当前脚本的文件名</td></tr><tr><td>$n</td><td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。</td></tr><tr><td>$#</td><td>传递给脚本或函数的参数个数。</td></tr><tr><td>$*</td><td>传递给脚本或函数的所有参数。被双引号(“ “)包含时，返回用空格分隔开各参数的字符串。</td></tr><tr><td>$@</td><td>传递给脚本或函数的所有参数。被双引号(“ “)包含时，返回一个参数的数组。</td></tr><tr><td>$?</td><td>上个命令的退出状态，或函数的返回值。</td></tr><tr><td>$$</td><td>当前Shell进程ID。在 Shell 脚本中的话就对应运行这脚本所在的进程ID。</td></tr></tbody></table><h1 id="tar-解压文件"><a href="#tar-解压文件" class="headerlink" title="tar 解压文件"></a>tar 解压文件</h1><p>指令是 tar</p><p>对于后缀名中有 .tar 的，需要带参数 x 表示解压缩，与之对应的是参数 c 表示将制定目录压缩成一个压缩文件。</p><p>对于后缀名带有 .gz 的，要带参数 z 表示需要 gzip 参与。解压缩与压缩都是这个参数。</p><p>带 v 参数则会输出解压缩过程。</p><p>带 f 参数后才可以跟待解压文件的文件名，如果仅使用上述参数就跟文件名（tar -xvz nginx-1.18.0.tar.gz） 会得到这样的错误提示： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">COPYtar: Refusing to <span class="hljs-built_in">read</span> archive contents from terminal (missing -f option?)<br>tar: Error is not recoverable: exiting now<br></code></pre></td></tr></table></figure><p>在参数 C 后跟压缩文件被解压到的文件夹。注意：文件夹自身必须已经存在。</p><p>综上所述，解压一个 &#x2F;nginx-1.18.0.tar.gz 可以使用如下代码</p><p><code>tar -xvzf ./nginx-1.18.0.tar.gz -C /usr/nginx/1.18.0/</code></p><h1 id="Is-the-system-based-on-AMD64"><a href="#Is-the-system-based-on-AMD64" class="headerlink" title="Is the system based on AMD64"></a>Is the system based on AMD64</h1><p>在下载软件的时候，经常会看到文件名后面跟着架构 -amd64, -arm64 之类的。一般 PC 系统都是基于 AMD64 的 CPU 架构，可以通过如下方式确认：</p><p><code>uname -a</code> 或者 <code>cat /proc/version</code></p><p>得到如下结果，其中 -amd64 表明是 AMD64 架构。</p><p><code>Linux VM-133-145-debian 4.9.0-12-amd64 #1 SMP Debian 4.9.210-1 (2020-01-20) x86_64 GNU/Linux</code></p><h1 id="当前系统是什么版本"><a href="#当前系统是什么版本" class="headerlink" title="当前系统是什么版本"></a>当前系统是什么版本</h1><p>遗忘了自己当初选择安装了什么版本的系统，只记得是 debian？可以用如下命令检查：</p><p><code>lsb_release -a</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">No LSB modules are available.<br>Distributor ID:    Debian<br>Description:    Debian GNU/Linux 9.0 (stretch)<br>Release:    9.0<br>Codename:    stretch<br></code></pre></td></tr></table></figure><p><a href="https://www.tecmint.com/check-debian-version/">How to Check Debian Linux Version</a></p><blockquote><p>It’s quite often that we keep forgetting which version of the Debian operating system we are using and this mostly happens when you log in to the Debian server after a long time or are you looking for a software that is available for a specific version of Debian only.</p></blockquote><h1 id="systemctl-系统服务管理器"><a href="#systemctl-系统服务管理器" class="headerlink" title="systemctl 系统服务管理器"></a>systemctl 系统服务管理器</h1><p>通过 apt-get 等包管理安装的软件一般会向系统注册自己的服务，之后可通过 systemctl 来管理。</p><p>从源码编译安装（比如Redis就可以这么装）的软件也可能配置了向 systemctl 注册自己服务的步骤。</p><h2 id="确认-systemctl-本身已经安装"><a href="#确认-systemctl-本身已经安装" class="headerlink" title="确认 systemctl 本身已经安装"></a>确认 systemctl 本身已经安装</h2><p><code>systemctl --version</code></p><p>如果 systemctl 本身已经安装，应该得到其版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@VM-133-145-debian:~<span class="hljs-comment"># clear</span><br>root@VM-133-145-debian:~<span class="hljs-comment"># systemctl --version</span><br>systemd 232<br>+PAM +AUDIT +SELINUX +IMA +APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ +LZ4 +SECCOMP +BLKID +ELFUTILS +KMOD +IDN<br></code></pre></td></tr></table></figure><h2 id="使用-systemctl-列出所有服务"><a href="#使用-systemctl-列出所有服务" class="headerlink" title="使用 systemctl 列出所有服务"></a>使用 systemctl 列出所有服务</h2><p>包括此时并不在运行的。</p><p><code>systemctl</code></p><p>可以结合 <code>grep</code> 使用</p><p>比如，找到 nginx 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@VM-133-145-debian:~<span class="hljs-comment"># systemctl | grep nginx</span><br>nginx.service    loaded active running   A high performance web server and a reverse proxy server        enabled<br></code></pre></td></tr></table></figure><p>比如，只看正在运行中的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@VM-133-145-debian:~<span class="hljs-comment"># systemctl | grep running</span><br>acpid.path                                                        loaded active running   ACPI Events Check                                                 <br>init.scope                                                        loaded active running   System and Service Manager                                        <br>session-147197.scope                                              loaded active running   Session 147197 of user root                                       <br>acpid.service                                                     loaded active running   ACPI event daemon                                                 <br>cron.service                                                      loaded active running   Regular background program processing daemon                      <br><span class="hljs-comment">#...</span><br></code></pre></td></tr></table></figure><h2 id="检查某个服务的运行状态"><a href="#检查某个服务的运行状态" class="headerlink" title="检查某个服务的运行状态"></a>检查某个服务的运行状态</h2><p><code>systemctl status $&#123;service-name&#125;</code></p><p>检查名为 service-name 的服务的运行状态。</p><p>一个正常运行的程序在查询时得到的结果应该和如下类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@VM-4-3-debian:~/downloads<span class="hljs-comment"># systemctl status mysql</span><br>● mysql.service - MySQL Community Server<br>   Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled)<br>   Active: active (running) since Fri 2020-11-06 13:39:01 HKT; 51min ago<br>  Process: 15291 ExecStartPre=/usr/share/mysql/mysql-systemd-start pre (code=exited, status=0/SUCCESS)<br>  Process: 15326 ExecStart=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid (code=exited, status=0/SUCCESS)<br> Main PID: 15328 (mysqld)<br>    Tasks: 28 (<span class="hljs-built_in">limit</span>: 2202)<br>   Memory: 181.6M<br>   CGroup: /system.slice/mysql.service<br>           └─15328 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid<br><br>Nov 06 13:39:01 VM-4-3-debian systemd[1]: Starting MySQL Community Server...<br>Nov 06 13:39:01 VM-4-3-debian systemd[1]: Started MySQL Community Server.<br></code></pre></td></tr></table></figure><p>一个不存在的程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@VM-4-3-debian:~/downloads<span class="hljs-comment"># systemctl status redis</span><br>Unit redis.service could not be found.<br></code></pre></td></tr></table></figure><h2 id="控制一个服务启停"><a href="#控制一个服务启停" class="headerlink" title="控制一个服务启停"></a>控制一个服务启停</h2><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl start httpd<br><span class="hljs-params">system</span>ctl restart httpd<br><span class="hljs-params">system</span>ctl stop httpd<br><span class="hljs-params">system</span>ctl reload httpd<br><span class="hljs-params">system</span>ctl kill httpd<br></code></pre></td></tr></table></figure><p>启动，重启，停止，重载和杀死 httpd 服务。这里 httpd 可以更换为其它服务。注意到之前列出所有服务时，被列出的服务都跟着一个 .service，这个其实是可以省略的。</p><p><code>systemctl enable xxx.service</code> 可以使某个服务开机自动启动</p><p><code>systemctl disable xxx.service</code> 则是禁止某个服务开机自动启动</p><h2 id="将一个软件注册为-systemctl-的服务"><a href="#将一个软件注册为-systemctl-的服务" class="headerlink" title="将一个软件注册为 systemctl 的服务"></a>将一个软件注册为 systemctl 的服务</h2><p>鉴于 apt-get 上的很多软件的版本都相比最新稳定版要旧，不可避免地要遇到自行手动编译安装一个软件的情况。将这样的软件托管到 systemctl 将便于调整其开机启动与否的配置以及控制服务启动，重启，停止。</p><p>以手动编译安装的 Nginx 为例。编译安装的过程与本节无关，结果上最后 Nginx 被安装在了 <code>/usr/local/nginx/</code> 中。若不使用 systemctl ，则启动 Nginx 的指令为 <code>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</code>，重启 Nginx 的命令为 <code>/usr/local/nginx/sbin/nginx -s reload</code>，停止 Nginx 的命令为 <code>/usr/local/nginx/sbin/nginx -s stop</code>。</p><p>而我们想要可以通过</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl start nginx<br><span class="hljs-params">system</span>ctl restart nginx<br><span class="hljs-params">system</span>ctl stop nginx<br></code></pre></td></tr></table></figure><p>来控制 nginx 服务。</p><p>实现方法：</p><p><code> systemctl edit --force nginx.service</code></p><p>调用 systemctl 为 nginx 服务编辑配置文件，由于 nginx 之前并未注册，所以不存在编辑。但因为 <code>--force</code> 参数，所以 systemctl 就会为其创建一个配置文件以编辑。这个文件在 <code>/etc/systemd/system/nginx.service</code> 目录下。</p><p>编辑 <code>/etc/systemd/system/nginx.service/nginx.service</code> 文件，添加如下内容：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[Unit]<br><span class="hljs-keyword">Description</span>=nginx - high performance web server<br>After=network.target remote-fs.target nss-lookup.target<br><br>[Service]<br>Type=forking<br>ExecStart=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin<span class="hljs-regexp">/nginx -c /u</span>sr<span class="hljs-regexp">/local/</span>nginx<span class="hljs-regexp">/conf/</span>nginx.conf<br>ExecReload=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin/nginx -s reload<br>ExecStop=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin/nginx -s stop<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>其中各字段的意义是：</p><blockquote><p>[Unit]：systemctl 认为每个被管理的资源都是一个 Unit。<br>Description：描述该服务。</p><p>After：依赖，当依赖的服务启动之后再启动自定义的服务。</p><p>[Service]：服务运行参数的设置</p><p>Type：程序运行的形式。forking指程序在后台运行。</p><p>ExecStart：systemctl start nginx.service 时调用这个字段的值。这里不能使用别名，依赖PATH路径和相对路径之类的偷懒写法。</p><p>ExecReload：对应 systemctl reload</p><p>ExecStop：对应 systemctl stop</p><p>注意：启动、重启、停止等命令的值中必须使用绝对路径。</p><p>[Install] 服务安装的相关设置</p><p>wantedBy：挂载在 &#x2F;etc&#x2F;systemd&#x2F;system&#x2F; 目录下的哪个文件夹里。这个字段的值还有其他指导服务挂载和安装的语义的作用，但我没有搜索到靠谱资料，一般都是 multi-user.target。</p></blockquote><p>使用 <code>systemctl daemon-reload nginx.service</code> 让 systemctl 重载服务的配置文件。之后<code>systemctl start nginx</code>等就可用了。</p><h1 id="x2F-usr-与-x2F-usr-x2F-local-与-x2F-opt"><a href="#x2F-usr-与-x2F-usr-x2F-local-与-x2F-opt" class="headerlink" title="&#x2F;usr 与 &#x2F;usr&#x2F;local 与 &#x2F;opt"></a>&#x2F;usr 与 &#x2F;usr&#x2F;local 与 &#x2F;opt</h1><p>linux 中 <code>/opt</code> 目录用来安装附加软件包，是用户级的程序目录，可以理解为 <code>D:/Software</code>。被安装到 &#x2F;opt 目录下的程序，应当满足所有的数据、库文件等等都是放在同个目录下面。类比于 windows 系统，有点像我们下载到了一个软件的绿色解压即用版，然后我们把压缩包解压缩出来得到一个文件夹，里面包含这个软件的所有文件。这个文件夹就该放到<code>D:/Software</code>。</p><p>opt 有可选的意思，这里可以用于放置第三方大型软件。当你不需要时，直接 rm -rf 掉即可。在硬盘容量不够时，也可将 &#x2F;opt 单独挂载到其他磁盘上使用。</p><p>linux 中 <code>/usr</code> 为系统级的目录，可以理解为 C:&#x2F;Windows&#x2F;。</p><p>linux 中 <code>/usr/local</code> 目录为用户级的程序目录，可以理解为 C:&#x2F;Progrem Files&#x2F;。用户自己编译安装的软件一般默认会安装到这个目录下。apt-get 安装的软件一般也是。</p><h1 id="确认某个进程使用的用户"><a href="#确认某个进程使用的用户" class="headerlink" title="确认某个进程使用的用户"></a>确认某个进程使用的用户</h1><p>在编译安装了 nginx 后，在访问网页资源时遇到了 403 错误，猜测原因是 Nginx 并无权限访问文档根目录。此时确认自己的猜测原因就需要了解 nginx 的主进程是以什么用户在运行的。</p><p>因此输入 <code>ps aux | grep nginx</code> 得到：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nobody</span> <span class="hljs-number">31731</span> <span class="hljs-number">0</span>.<span class="hljs-number">0</span> <span class="hljs-number">0</span>.<span class="hljs-number">1</span> <span class="hljs-number">25376</span> <span class="hljs-number">2304</span> ? S <span class="hljs-number">16</span>:<span class="hljs-number">39</span> <span class="hljs-number">0</span>:<span class="hljs-number">00</span> nginx: worker process<br></code></pre></td></tr></table></figure><p>第一列的结果 nobody 表明 Nginx 的主进程以 nobody 用户运行而非 root，因此猜想基本是正确的。</p><p>既然都说到这里了解决方案也就说了吧。在 Nginx 的配置文件（一般是 <code>/usr/local/nginx/conf/nginx.conf</code> ）中最高层级添加 user root 使得 Nginx 以 root 身份运行。</p><h1 id="修改某个文件-x2F-文件夹的权限控制"><a href="#修改某个文件-x2F-文件夹的权限控制" class="headerlink" title="修改某个文件&#x2F;文件夹的权限控制"></a>修改某个文件&#x2F;文件夹的权限控制</h1><p>chmod 命令，其最常见的用法的参数搭配是这样的：</p><p><code>chmod [ugoa][+-=][rwxX]</code></p><p>其中三个参数依次意义为</p><p>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</p><ul><li>表示增加权限、- 表示取消权限、&#x3D; 表示唯一设定权限。<br>r 表示可读取，w 表示可写入，x 表示可执行。</li></ul><h1 id="管理-Java-程序"><a href="#管理-Java-程序" class="headerlink" title="管理 Java 程序"></a>管理 Java 程序</h1><p>如果在一个终端上输入 <code>java -jar a-project.jar</code> 或 <code>mvn spring-boot:run</code>，则这个终端将被这个指令的后续输出给占用。同时如果关闭这个终端，其它终端也管不到这个 java 程序。这两件事都是不运维的。</p><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p><code>nohup command [&gt;file.out] [2&gt;&amp;1] [&amp;]</code></p><p>command 将标准输出输出到 file.out 文件，从而避免了 command 命令的标准输出占用当前终端的问题。这里的 file.out 当然是可以随便改名的，my-project-name.log什么的都行。但是文件所在的文件夹必须都已经存在，nohup只会创建文件，不创建文件夹。</p><p>如果省略 <code>&gt;file.out</code>，则默认重定向到 .&#x2F;nohup.out。</p><p>如果最终的结尾不带 &amp;，则 command 的标准输出被重定向了，但nohup命令的标准输出没重定向，还是会占用当前终端。而带上 &amp; 则不会有此问题。</p><p><code>[2&gt;&amp;1]</code> 中 2 代表的是标准错误输出（stderr），&amp;1 代表的是标准输出（stdout），这整个参数的意思就是将标准错误输出输出的目标重定向到标准输出（的输出目标）。而由于前面已经将标准输出重定向到 file.out，故最终 stderr 也重定向到 file.out。</p><p>因此我们可以写出这样一个 bash 脚本来管理 Java 程序的启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">COPY<span class="hljs-comment">#!/bin/bash</span><br><br><span class="hljs-built_in">cd</span> ~/projects/example/example-backend/<br><br><span class="hljs-built_in">nohup</span> mvn spring-boot:run &gt;~/projects/example/logs/example.out 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><h2 id="netstat-与-grep-与-awk-与-xargs"><a href="#netstat-与-grep-与-awk-与-xargs" class="headerlink" title="netstat 与 grep 与 awk 与 xargs"></a>netstat 与 grep 与 awk 与 xargs</h2><p>在用 bash 脚本管理了 Java 程序的启动后，剩下的问题是如何结束这个 Java 程序。</p><p>此处先给出解决方案再来分析:</p><p><code>netstat -lp | grep 7500 | awk &#39;&#123;print $7&#125;&#39; | awk -F/ &#39;&#123;print $1&#125;&#39; | xargs kill -15;</code></p><p>然后分析这个命令是怎么回事儿。</p><p>首先是管道符 |，它能够将前一个命令的标准输出作为后一个命令的标准输入传过去。</p><p>然后是 netstat，它可以显示网络状态。我这里的思路是建立在我的 Java 程序是一个 Web 后台应用，并且我配置了这个 java 程序监听 7500 端口。因此相比 <code>ps -ef | grep java</code> 我觉得去筛选出监听 7500 端口的那行程序更精确一点。</p><p>而 <code>netstat -lp -lp</code> 中，p 参数较为重要，它的意义是显示正在使用Socket的程序识别码和程序名称，如果没有这个参数，即便得到了那一行，那一行里也没有那个 Java 程序的 PID，也就不可能发给 <code>kill -15</code> 去关闭。另一个 l 参数则是将展示的 Socket 过滤一遍，只展示其中我方主机作为 server 的套接字。这个其实加不加对于脚本命令影响不大，因为最后都能被 grep 7500 筛出那一行 Java 程序。不过加了之后会让输出的内容在人阅读时更友好。</p><p>再然后是 awk 命令。</p><p>awk 默认将空格（或者说连续的空格）和 Tab 作为分隔符，而 ‘{print $7}’ 的意思就是利用分隔符分隔后，把从左往右数的第7个内容给输出到标准输出上。</p><p><code>netstat -lp | grep 7500</code> 产生的输出是这样的：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">tcp6 <span class="hljs-number">0</span> <span class="hljs-number">0</span> [::]<span class="hljs-symbol">:</span><span class="hljs-number">7500</span> [::]<span class="hljs-symbol">:*</span> <span class="hljs-title class_">LISTEN</span> <span class="hljs-number">21494</span>/java<br></code></pre></td></tr></table></figure><p>以空格（连续的空格）为分隔符进行分隔的话，则分别有tcp6，0，0，[::]:7500，[::]:*，LISTEN和21494&#x2F;java。其中第七个的前半部分21494就是Java程序的PID了。</p><p>所以接下来要对 21494&#x2F;java 执行 <code>awk -F/ &#39;&#123;print $1&#125;</code> ,这里-F手动指定分隔符，-F&#x2F;的意思就是手动指定&#x2F;为分隔符，然后输出第一个，也就得到了 PID。</p><p>最后是 xargs 命令。为什么这里不能直接 | kill -15 呢？因为kill -15 期待的是一个作为参数的 PID 而不从标准输入里取 PID。而 xargs 的作用正是将自己的标准输入的内容转换为后面的指令的参数。如此搭配，也就最终等价于kill -15 21494了。</p><h1 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h1><p>使用 root 权限与 <code>passwd $&#123;username&#125;</code> 可以修改指定用户登入系统的密码。</p><p>使用 <code>passwd -S</code> 可以先得到当前系统中所有注册的账户。</p><h1 id="SSH-Login"><a href="#SSH-Login" class="headerlink" title="SSH Login"></a>SSH Login</h1><h2 id="Enable-SSH-Password-Login-via-root"><a href="#Enable-SSH-Password-Login-via-root" class="headerlink" title="Enable SSH Password Login via root"></a>Enable SSH Password Login via root</h2><p>Debian 上 SSH 默认是禁止外部通过 SSH 并基于密码校验的方式以 root 账号登进来的。所以我们需要先修改配置使其允许。</p><p>不过这一步对于云服务器来说应该是不需要的，我是因为用的 VM 虚拟机上装 Debian，所以要手动配置。云服务商应该提供了在控制台中添加本地SSH秘钥信息后帮助注入买的云服务器中，并默认开启SSH秘钥对验证，使用户可以快速使用SSH登进服务器系统。</p><p>可以参考<a href="https://webmentor.online/blog/how-to-enable-ssh-root-login-in-debian-11">How To Enable SSH Root Login In Debian 11</a>这篇文章。</p><p>这样我们就可以用 SSH 软件或者 VS Code 接入我们的系统，方便之后开启使用基于秘钥对的 SSH 验证机制。</p><p><code>nano /etc/ssh/sshd_config</code></p><p>在文件中找到包含 PermitRootLogin 的那一行，默认应该是 <code>#PermitRootLogin prohit-password</code>。</p><p>去掉注释符号，并将第二个参数的值改为 yes，即 <code>PermitRootLogin yes</code>。</p><p>配置的修改完成后，重启 ssh 服务：<code>systemctl restart ssh</code> 以使修改生效。</p><h2 id="Enable-SSH-key-auth-login"><a href="#Enable-SSH-key-auth-login" class="headerlink" title="Enable SSH key auth login"></a>Enable SSH key auth login</h2><p>编辑 <code>/etc/ssh/sshd_config</code> 使有如下的配置项：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">PubkeyAuthentication yes <br><br>AuthorizedKeysFile     <span class="hljs-regexp">/etc/</span>ssh<span class="hljs-regexp">/authorized_keys .ssh/</span>authorized_keys2<br></code></pre></td></tr></table></figure><p>然后在客户端这边的系统上找到这边的公钥，一般是 <code>~/.ssh/id_&#123;&#125;.pub</code> 文件的内容。复制之后，写入 <code>/root/.ssh/authorized_keys</code> 和 <code>/root/.ssh/authorized_keys2</code> 文件中。如果这两个文件还不存在，那就创建出来。这样以后 root 用户即可使用 key auth 登录，因为 <code>/root</code> 文件夹是 root 用户的家目录。</p><p>完成后仍然是 <code>systemctl restart ssh</code> 重启 ssh 服务以使新配置生效。之后这边使用 SSH 客户端即可 SSH Key Auth 登录服务器了。</p><h2 id="SSH-原理"><a href="#SSH-原理" class="headerlink" title="SSH 原理"></a>SSH 原理</h2><p>参考了<a href="https://www.jianshu.com/p/d31de2601368">SSH 认证原理</a>一文。</p><h3 id="密码验证方式"><a href="#密码验证方式" class="headerlink" title="密码验证方式"></a>密码验证方式</h3><p>远程主机收到用户的登录请求，把自己的公钥发给用户。</p><p>用户使用这个公钥，将登录密码加密后，发送回来。</p><p>远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</p><p>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像 https 协议，SSH 协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。</p><p>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的 wifi 区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么 SSH 的安全机制就荡然无存了。这种风险就是著名的中间人攻击。</p><p>这也是为什么第一次登录对方主机时系统会出现下面的提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">　　$ ssh user@host<br>　　The authenticity of host <span class="hljs-string">&#x27;host (12.18.429.21)&#x27;</span> can<span class="hljs-string">&#x27;t be established.</span><br><span class="hljs-string">　　RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="hljs-string">　　Are you sure you want to continue connecting (yes/no)?</span><br></code></pre></td></tr></table></figure><p>这段话的意思是，无法确认 host 主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？</p><p>所谓”公钥指纹”，是指公钥长度较长（这里采用 RSA 算法，长达 1024位），很难比对，所以对其进行 MD5 计算，将它变成一个 128 位的指纹。上例中是 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。</p><p>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。</p><p>用户输入 yes 表示认为自己的网络连接是安全的或者比对后认为指纹匹配之后，系统将这一公钥保存在文件 <code>$HOME/.ssh/known_hosts</code> 之中并做好与此主机的 IP 的匹配。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p><p>这之后可以输入目标主机的目标用户的密码以完成验证的后续步骤。</p><h3 id="Key-Auth"><a href="#Key-Auth" class="headerlink" title="Key Auth"></a>Key Auth</h3><p>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录，不再要求密码。</p><p>这里会采用非对称加密算法，即经过公钥加密的数据，无法再被公钥解密（所以即便公钥暴露也没有关系）只能被私钥解密。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象中的协变和逆变</title>
    <link href="/2023/01/28/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/"/>
    <url>/2023/01/28/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象中的协变和逆变"><a href="#面向对象中的协变和逆变" class="headerlink" title="面向对象中的协变和逆变"></a>面向对象中的协变和逆变</h1><h2 id="场景引入"><a href="#场景引入" class="headerlink" title="场景引入"></a>场景引入</h2><p><a href="https://www.zhihu.com/question/38861374/answer/1175835396">这篇知乎回答</a>给了本文很大启发。</p><p>一个专门做荔枝买卖的中间商 Exchanger 从农民 Producer 手中收购来荔枝，然后将它卖给销售商 Consumer，从中赚取利润。这是一个很常见的模式，我们首先将这里的三个对象完全抽象出来：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getPrice</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 本例中中间商，农民，经销商在本例中是水果市场的。</span><br><span class="hljs-comment"> * 但将它们复用在家电市场，木材市场也不无不可。</span><br><span class="hljs-comment"> * 因而这里应当都使用泛型对此加以抽象。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Exchanger</span>&lt;<span class="hljs-type">T : Product</span>&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> balance: <span class="hljs-built_in">Double</span> = <span class="hljs-number">0.0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">exchange</span><span class="hljs-params">(producer: <span class="hljs-type">Producer</span>&lt;<span class="hljs-type">T</span>&gt;, consumer: <span class="hljs-type">Consumer</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span>&lt;<span class="hljs-type">T : Product</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>: T &#123;<br>        <span class="hljs-comment">//省略</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-type">T : Product</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(product: <span class="hljs-type">T</span>)</span></span> &#123;<br>        <span class="hljs-comment">//省略</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于和专门做荔枝生意的中间商打交道的生产者，荔枝有很多不同的子种，比如妃子笑，元红等。某个生产者可能是专门只做一个子品种的荔枝的。而对于采购商，比如盒马生鲜，显然它们也不可能是只收荔枝的。这两点反应在代码上，就可能形成如下第六行代码的情况：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> 水果 : Product;<br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> 荔枝 : 水果();<br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> 妃子笑 : 荔枝();<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> exchanger = Exchanger&lt;荔枝&gt;();<br>    exchanger.exchange(Producer&lt;妃子笑&gt;(), Consumer&lt;水果&gt;()); <span class="hljs-comment">//line#6</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然而，就 kotlin 来说，此时编译器检查是通不过的，因为编译器认为第六行的方法调用中，传入的两个实参，其类型 <code>Producer&lt;妃子笑&gt;</code> 和 <code>Consumer&lt;水果&gt;</code> 的在此处与形参规定的类型冲突。</p><p>我想你不会对 <code>Consumer&lt;水果&gt;()</code> 用作方法的第二个参数是非法的这件事感到不解。因为水果显然比荔枝更抽象（即更父类）。而面向对象开发的惯例是方法的实参的类型，必须是参数要求的类型或那个类型的子类。</p><p>然而，你可能对 <code>Producer&lt;妃子笑&gt;()</code> 用作 exchange方法的第一个参数（类型要求是 <code> Producer&lt;荔枝&gt;</code> ）是非法的感到不解。而对于这一疑惑，其本质是 <code>Producer&lt;妃子笑&gt;</code> 难道不是 <code>Producer&lt;荔枝&gt;</code> 的子类吗？</p><p>那要回答这一问题，不妨类比地考量这个问题：<code>List&lt;Cat&gt;</code> 是不是 <code>List&lt;Animal&gt;</code> 的子类？</p><p>从概念上说，说 Cat 是 Animal 的子类是绝对没问题的。那 <code>List&lt;Cat&gt;</code> 是 <code>List&lt;Animal&gt;</code> 的子类吗？不是！说A是B的子类，那么从逻辑上讲A就是B，B能做的事情，A一定全部能做。</p><p>你可以向 <code>List&lt;Animal&gt;</code> 里放一只 Dog，你能往 <code>List&lt;Cat&gt;</code> 里放一只 Dog 吗？</p><h2 id="设计出协变和逆变"><a href="#设计出协变和逆变" class="headerlink" title="设计出协变和逆变"></a>设计出协变和逆变</h2><p>几乎所有支持面向对象的语言都认同  <code>List&lt;Cat&gt;</code> 不是 <code>List&lt;Animal&gt;</code> 的子类这一逻辑，反应到 OOP 领域中便是在泛型上存在着继承关系，不等于大类型存在继承关系，因此 <code>Producer&lt;妃子笑&gt;</code> 的实例作为要求 <code>Producer&lt;荔枝&gt;</code> 类型的参数不合法。然而，这个场景是真实存在且可能发生的，难道 OOP 对一个如此真实如此确实需要解决的场景束手无策？</p><p>OOP 领域的专家和语言开发者对这一问题投入了充分的审慎的思考，设计了协变和逆变。</p><p>让我们回到刚才的情形和代码，对 exchange 的方法咬文嚼字一下：，<code>fun exchange(producer: Producer&lt;荔枝&gt;, consumer: Consumer&lt;荔枝&gt;)</code> 在形参上表达的意思是：</p><ul><li>a 专门生产荔枝的生产者的子类</li><li>b 专门买荔枝的消费者的子类</li></ul><p>而我们想要表达的其实是：</p><ul><li>c 专门生产荔枝（荔枝的各种子品类都有种）或专门生产荔枝子类（比如只种植元红这一种的荔枝）的生产者</li><li>d 专门买荔枝或者采购范围内有荔枝的消费者</li></ul><p>请注意『的子类』的位置。</p><p>即语言设计者应当设计一些新的关键字或新的模式，使其能表达 c 或 d 项的含义。</p><p>协变和逆变便是对应 c 项和 d 项的术语。out 和 in 便是 Kotlin 开发者为协变和逆变设计的关键字。</p><p>更加准确地说，在 OOP 中，如果类型A是类型B的子类，对于一个使用泛型的类型C：当需要将类型 <code>C&lt;A,T,R...&gt;</code> 的实例用作形参类型为 <code>C&lt;B,T,R...&gt;</code> 的实参时，则称为允许协变；当需要将类型 <code>C&lt;B,T,R...&gt;</code> 的实例用作形参类型为C&lt;A,T,R…&gt;的实参时，则称为允许逆变。</p><p>那么落实到 Kotlin 这一语言中，如何支持这里的协变和逆变呢？答案是这样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">exchange</span><span class="hljs-params">(producer: <span class="hljs-type">Producer</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">T</span>&gt;, consumer: <span class="hljs-type">Consumer</span>&lt;<span class="hljs-type">in</span> <span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于之前，多了 out 和 in 关键字，用来表达在第一个参数上，校验传入的实例的类型时允许协变，在第二个参数上，传入的实例的类型允许发生逆变。具体地来说：</p><p>由于 out 关键字，传 <code>Producer&lt;妃子笑&gt;</code> 类型实例作第一个参数，OK，但是想在这里用 <code>Producer&lt;水果&gt;</code> 类型的实例做实参还是不行。</p><p>由于 in 关键字，传 <code>Consumer&lt;水果&gt;</code> 类型实例作第二个参数，OK，但 <code>Consumer&lt;妃子笑&gt;</code> 类型的实例做第二个实参还是不行。</p><p>那么 kotlin 为什么会选用 out 和 in 这两个单词来作为关键字呢？这是因为 kotlin 或者说 OOP 语言的开发者和实践者总结经验发现：</p><ul><li><strong>可以发生协变并应该对协变加以支持的情景（比如这里对 Producer 的使用），协变实参可以且应该仅可以对外输出（比如这里的 Producer，我们就只关心调用它的 produce 方法得到它输出的产品）。</strong></li><li><strong>类似地，可以发生逆变且应该对逆变加以支持的情景（比如这里对 Consumer 的使用），都是逆变实参接收输入的场景（比如这里的 Consumer 通过 consume 方法获在接收输入）。</strong></li></ul><p>因此，用 out 对应协变场景，用 in 对应逆变场景。</p><p>对于这一经验总结，是否能在数学领域上给出坚强的论证？我觉得可能是有的，但我确实没有找到。</p><h2 id="out-和-in-的限制"><a href="#out-和-in-的限制" class="headerlink" title="out 和 in 的限制"></a>out 和 in 的限制</h2><p>上节说到 kotlin 用 out 来支持协变，用 in 来支持逆变。但是这一支持并不完全，或者说虽然允许了协变、逆变，但被声明可以进行协变、逆变处的参数的使用遭到了限制。</p><ul><li>被 out 支持了协变的类型声明的参数，它将被限制不能调用它的类所提供的方法里参数表中有『类型声明中包含被支持协变的泛型』的参数的方法。—— 协变总是发生在方法的返回值类型（函数的返回值相当于它的对外输出）上</li><li>被 in 支持了逆变的类型声明的参数，它将被限制不能调用它的类所提供的方法里返回值类型的声明中包含被支持逆变的泛型的方法。—— 逆变总是发生在方法某个（些）参数的类型（函数的参数需要被传入，相当于获得）上。</li></ul><p>为了演示，我们突破逻辑，让类 Producer 也具有一个 Consumer 方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span>&lt;<span class="hljs-type">T : Product</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>: T &#123;<br>        TODO();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(thing: <span class="hljs-type">T</span>)</span></span> &#123;<br>        TODO();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>并尝试在 <code>fun exchange(producer: Producer&lt;out T&gt;, consumer: Consumer&lt;in T&gt;)</code> 中使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">exchange</span><span class="hljs-params">(producer: <span class="hljs-type">Producer</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">T</span>&gt;, consumer: <span class="hljs-type">Consumer</span>&lt;<span class="hljs-type">in</span> <span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> product = producer.produce()<br>    producer.consume(product); <span class="hljs-comment">// line#3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>编译器对第三行的代码报错。因为 exchange 方法声明第一个参数允许类型T协变。而 consume 函数的参数表中有一个 <code>thing: T</code> ，因而这个方法在 exchange 中不允许参数 producer 调用。</p><p>样突破逻辑，让类 Consumer 有一个 produce 方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-type">T : Product</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(product: <span class="hljs-type">T</span>)</span></span> &#123;<br>        TODO();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>: T &#123;<br>        TODO();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样实机尝试一下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">exchange</span><span class="hljs-params">(producer: <span class="hljs-type">Producer</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">T</span>&gt;, consumer: <span class="hljs-type">Consumer</span>&lt;<span class="hljs-type">in</span> <span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> product: T = consumer.produce();<br>&#125;<br></code></pre></td></tr></table></figure><p>同样报错。不过如果改为如下代码，即明确声明并不要求返回值的类型后可通过编译。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">exchange</span><span class="hljs-params">(producer: <span class="hljs-type">Producer</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">T</span>&gt;, consumer: <span class="hljs-type">Consumer</span>&lt;<span class="hljs-type">in</span> <span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> product: Any? = consumer.produce();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="限制的收益"><a href="#限制的收益" class="headerlink" title="限制的收益"></a>限制的收益</h2><p>举例说明吧。首先是相关基础代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name: String)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Buccaneer</span>(name: String): Person(name)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Naruto</span>(name: String): Person(name)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">trick</span><span class="hljs-params">(c: <span class="hljs-type">Container</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">Person</span>&gt;, person: <span class="hljs-type">Person</span>)</span></span> &#123;<br>    c.item = person; <span class="hljs-comment">// 此处报错因为 c.item = c.setItem, 而 setItem 形参表中有 item:T</span><br>&#125;<br></code></pre></td></tr></table></figure><p>第6行因为限制的存在会报错，因为 <code>c.item = this.item</code> 等价于 <code>c.setItem(this.item)</code> , 而 <code>setItem</code> 形参表中有 <code>item:T</code> 。</p><p>如果限制不存在，以上代码均合法，那么如下代码也会是合法的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> container = Container&lt;Buccaneer&gt;(Buccaneer(<span class="hljs-string">&quot;路飞&quot;</span>))<br>    trick(container, Container&lt;Naruto&gt;(Naruto(<span class="hljs-string">&quot;鸣人&quot;</span>))<br>    <span class="hljs-keyword">val</span> p: Buccaneer = container.person;<br>&#125;<br></code></pre></td></tr></table></figure><p>进而我们在第四行从容器中取出的并不是预想的一个海贼，而是一个忍者。</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA使用笔记</title>
    <link href="/2023/01/24/IDEA%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/01/24/IDEA%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="IDEA使用笔记"><a href="#IDEA使用笔记" class="headerlink" title="IDEA使用笔记"></a>IDEA使用笔记</h1><h2 id="设置调整类"><a href="#设置调整类" class="headerlink" title="设置调整类"></a>设置调整类</h2><h3 id="代码提示大小写不敏感"><a href="#代码提示大小写不敏感" class="headerlink" title="代码提示大小写不敏感"></a>代码提示大小写不敏感</h3><p><img src="https://i.loli.net/2020/03/12/qvG8rSt5zBPObT6.jpg" alt="大小写不敏感.jpg"></p><h3 id="java注释风格"><a href="#java注释风格" class="headerlink" title="java注释风格"></a>java注释风格</h3><p>这里的注释是指通过<code>Ctrl+/</code>快捷键自动注释，如果不修改，默认会将<code>//</code>添加到行首，看着很别扭，我希望<code>//</code>能和前后的代码保持相同缩进。</p><p><img src="https://i.loli.net/2020/03/12/IvmROoJjEuAK9Ly.jpg" alt="注释风格.jpg"></p><h3 id="调整补全建议唤出的快捷键"><a href="#调整补全建议唤出的快捷键" class="headerlink" title="调整补全建议唤出的快捷键"></a>调整补全建议唤出的快捷键</h3><p><img src="https://i.loli.net/2020/03/12/oJGt2jlUVmD63dO.jpg" alt="补全建议替换.jpg"></p><h3 id="启动时不自动打开上一次项目"><a href="#启动时不自动打开上一次项目" class="headerlink" title="启动时不自动打开上一次项目"></a>启动时不自动打开上一次项目</h3><p><img src="https://i.loli.net/2020/03/12/xgc8Pk1LhAm49ZG.jpg" alt="启动时.jpg"></p><h3 id="java代码自动换行"><a href="#java代码自动换行" class="headerlink" title="java代码自动换行"></a>java代码自动换行</h3><p><img src="https://i.loli.net/2020/03/12/pxbtqB1o3gOfuSG.jpg" alt="自动换行.jpg"></p><p>这里 Ensure right margin is not exceeded 是关键，但因为我使用了<code>Material Theme UI</code>工具，样式有了一些变化，所以又调整了一下 Hard wrap at 缩小了页面一行容许容纳的字符数，保证不超出视界。</p><p><img src="https://i.loli.net/2020/03/12/fKM4BZ9LRzqIei1.png" alt="缩进.png"></p><p>注意这张图右边黄色框里被箭头指着的很细很细几乎看不见的竖线，就是界限了。如果代码超过了这个界限，在按下<code>ctrl + alt + L</code>即要求代码自动格式化后，IDEA 就会尽可能地将代码放回到界限以内。</p><h3 id="为-Lombok-开启注解预处理"><a href="#为-Lombok-开启注解预处理" class="headerlink" title="为 Lombok 开启注解预处理"></a>为 Lombok 开启注解预处理</h3><p><img src="https://i.loli.net/2020/03/12/xQ4bZmKL2aGSPgR.png" alt="注解预处理.png"></p><h3 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h3><p><img src="https://i.loli.net/2020/03/12/RT9xVE2GhLcoYq4.png" alt="proxy1.png"></p><p>如图所示，其中选用 SOCKS 还是和 HTTP 导致的唯一可能不同在于端口（Prot Number），如图所示。HTTP 的端口就是下图中没有前缀的 Port 的端口 10809。 Host name 是固定的 127.0.0.1，这是IP协议规定的表达本机的IP地址。</p><p><img src="https://i.loli.net/2020/03/12/pEZfm2bQIuiVXtY.png" alt="proxy2.png"></p><p>要代理，自己首先要有提供代理服务的主机和代理用的软件。代理服务我是找服务商买的，在买的时候服务商又有让设置机场的名字和密码，即这里 Proxy authentication 中的 Login 和 Password。</p><h3 id="git-相关快捷键设置"><a href="#git-相关快捷键设置" class="headerlink" title="git 相关快捷键设置"></a>git 相关快捷键设置</h3><p><img src="https://i.loli.net/2020/03/12/IY2GQzWBaRAT6DK.png" alt="gitee相关快捷键.png"></p><p>如图，将 git push 快捷键设定为 <code>Ctrl + Shift + K</code>。别看这里好像有很多个地方要设置，其实设置一处其它地方就都同步改了。</p><p>善用搜索，add 和 commit 用搜索搜出来改即可。 add  对应的操作全名是 Add to VCS，Commit 对应的是 Comit… ，不带 File， 不是 Commit File。</p><p>使用时建议先用 <code>alt + 9</code> 切换到 版本控制选项卡下，在 add commit push 一键三连。</p><h3 id="光标所在行颜色调整"><a href="#光标所在行颜色调整" class="headerlink" title="光标所在行颜色调整"></a>光标所在行颜色调整</h3><p><img src="https://i.loli.net/2020/04/09/pcjs4nPEkOGaUhL.png" alt="光标与光标行颜色.png"></p><p>如图所示，其中 Caret 代表光标，即那个一闪一闪的横线，提示着接下来输入的内容会在什么位置。</p><p>而 Caret row 就是指光标所在的行的颜色。</p><p>除此之外还有许多其它设置可以调整从而使代码看起来更加醒目。</p><h3 id="DEBUG时显示null"><a href="#DEBUG时显示null" class="headerlink" title="DEBUG时显示null"></a>DEBUG时显示null</h3><p><img src="https://s1.ax1x.com/2020/04/22/JYTYQK.png" alt="效果图"></p><p>如图所示，如果不在下方的设置中设置的话，这个<code>null</code>并不会显式地出现。</p><p><img src="https://s1.ax1x.com/2020/04/22/JYTtsO.png" alt="设置方式"></p><h2 id="使用的插件"><a href="#使用的插件" class="headerlink" title="使用的插件"></a>使用的插件</h2><h3 id="ignore"><a href="#ignore" class="headerlink" title=".ignore"></a>.ignore</h3><p><a href="https://plugins.jetbrains.com/plugin/7495--ignore/">.ignore</a> 可以帮助快速创建 git 要忽略的文件和文件夹的匹配规则</p><h3 id="Free-MyBatis-plugin"><a href="#Free-MyBatis-plugin" class="headerlink" title="Free MyBatis plugin"></a>Free MyBatis plugin</h3><p><a href="https://plugins.jetbrains.com/plugin/8321-free-mybatis-plugin/">Free MyBatis plugin</a> 免费的加强IDEA对mybatis的支持的插件</p><h3 id="key-promoter-x"><a href="#key-promoter-x" class="headerlink" title="key-promoter-x"></a>key-promoter-x</h3><p><a href="https://plugins.jetbrains.com/plugin/9792-key-promoter-x/">key-promoter-x</a> 每当用鼠标点击用快捷键就能做到的按钮时，会自动提示你应该用什么快捷键。对多次用鼠标点击的操作，会提示你是否要为它设置快捷键。</p><h3 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h3><p><a href="https://plugins.jetbrains.com/plugin/6317-lombok/">Lombok</a> 结合 Lombok 的jar包，可以通过在类上加<code>@Getter</code> <code>@Setter</code> <code>@ToString</code> 这样的注解使类自动生成相关的方法而不用手写。</p><h3 id="Material-Theme-UI"><a href="#Material-Theme-UI" class="headerlink" title="Material Theme UI"></a>Material Theme UI</h3><p><a href="https://plugins.jetbrains.com/plugin/8006-material-theme-ui/">Material Theme UI</a> 对IDEA的布局做了一些调整，并有一些更漂亮的配色主题，使IDEA更好看。</p><h3 id="Rainbow-Brackets"><a href="#Rainbow-Brackets" class="headerlink" title="Rainbow Brackets"></a>Rainbow Brackets</h3><p><a href="https://plugins.jetbrains.com/plugin/10080-rainbow-brackets/">Rainbow Brackets</a> 不同层级的括号有着相差相当大的颜色，从而更好确认块的范围。</p><h3 id="Code-Glance"><a href="#Code-Glance" class="headerlink" title="Code Glance"></a>Code Glance</h3><p><a href="https://plugins.jetbrains.com/plugin/7275-codeglance/versions">Code Glance</a>  在编辑器右侧开辟一块区域放置当前文件代码的小地图，从而方便大型文件里的移动。</p><h3 id="Grep-Console"><a href="#Grep-Console" class="headerlink" title="Grep Console"></a>Grep Console</h3><p><a href="https://plugins.jetbrains.com/plugin/7125-grep-console">Grep Console</a> 通过在插件中设置包含什么关键词的输出在IDEA控制台上的记录要用什么颜色（这一整条都会变色），而使IDEA控制台上产生的信息颜色多样从而更可读。通过设置如<code>INFO</code>,<code>WARN</code>这种表明日志记录的等级的，可以使可读性大大提升。</p><p><img src="https://i.loli.net/2020/03/12/gPdxGsWnC6YoEO2.png" alt="grepconsole.png"></p><h3 id="IDEALog"><a href="#IDEALog" class="headerlink" title="IDEALog"></a>IDEALog</h3><p><a href="https://plugins.jetbrains.com/plugin/index?xmlId=com.intellij.ideolog">IDEALog</a> 用IDEA打开<code>.log</code>文件后，它会在样式和格式上起到一些帮助。</p><h3 id="Maven-Helper"><a href="#Maven-Helper" class="headerlink" title="Maven Helper"></a>Maven Helper</h3><p><a href="https://plugins.jetbrains.com/plugin/index?xmlId=MavenRunHelper">Maven Helper</a> 在 pom.xml 文件下给出一个选项卡，点进去后可以更可视化地方便地管理依赖。</p><p><img src="https://i.loli.net/2020/03/12/RDQt4ChybaSpnGW.png" alt="mavenhelper.png"></p><h3 id="mybatis-log-plugin"><a href="#mybatis-log-plugin" class="headerlink" title="mybatis log plugin"></a>mybatis log plugin</h3><p><a href="https://plugins.jetbrains.com/plugin/10065-mybatis-log-plugin/">mybatis log plugin</a>  在控制台，运行状态等等的底部选项卡中又多了这个插件提供的展示台，里面会记录软件运行后发生的调用 mybatis 对 mysql 的 CRUD 与原生 mysql 语句相近的语句。</p><h3 id="RestfulToolkit"><a href="#RestfulToolkit" class="headerlink" title="RestfulToolkit"></a>RestfulToolkit</h3><p><a href="https://plugins.jetbrains.com/plugin/10292-restfultoolkit">RestfulToolkit</a> （猜测是通过统计和管理<code>@RequestMapping</code>注解）在侧边栏多提供一个该插件提供的展示台，里面包含项目（有意义且仅对web项目有意义）中所有对外的接口。</p><h2 id="值得记背的快捷键"><a href="#值得记背的快捷键" class="headerlink" title="值得记背的快捷键"></a>值得记背的快捷键</h2><h3 id="切换底部选项卡"><a href="#切换底部选项卡" class="headerlink" title="切换底部选项卡"></a>切换底部选项卡</h3><p><code>alt + 1</code> 切换到文件视图</p><p><code>alt + 4</code> 软件运行时的输出控制台 springboot 启动后会自动切换到此选项卡</p><p><code>alt + 9</code> 切换到版本控制（git）试图</p><p><code>alt + F12</code> 切换到cmd，powershell之类的系统的终端。</p><h3 id="智能提示继续写什么和智能补完"><a href="#智能提示继续写什么和智能补完" class="headerlink" title="智能提示继续写什么和智能补完"></a>智能提示继续写什么和智能补完</h3><p>由于<a href="#%E8%B0%83%E6%95%B4%E8%A1%A5%E5%85%A8%E5%BB%BA%E8%AE%AE%E5%94%A4%E5%87%BA%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE">调整补全建议唤出的快捷键</a>小节中的设置，在我使用时为<code>Ctrl + ,</code>和<code>Shift + Ctrl + ,</code>。</p><h3 id="获取正在调用的方法的详细信息-和-参数表"><a href="#获取正在调用的方法的详细信息-和-参数表" class="headerlink" title="获取正在调用的方法的详细信息 和 参数表"></a>获取正在调用的方法的详细信息 和 参数表</h3><p>比如使用<code>System.out.println(&quot;hello&quot;)</code>时突然忘记了<code>println</code>是个什么用处的方法了，那么把光标放到<code>println</code>内部，按下<code>Ctrl + Q</code>就会展现该方法上面的注释和参数表。光标停留在<code>println(...)</code>的参数表中即<code>...</code>部分上时，按下<code>Ctrl + P</code>就会显示可用的参数表。</p><h3 id="获取光标在其方法体中的方法的签名"><a href="#获取光标在其方法体中的方法的签名" class="headerlink" title="获取光标在其方法体中的方法的签名"></a>获取光标在其方法体中的方法的签名</h3><p>比如在主类的<code>main</code>方法里写<code>System.out.println(&quot;Hello&quot;)</code>，假设光标停在<code>println</code>里，此时按下<code>Alt + Q</code>,会开个小窗飘在左上角展示<code>main</code>方法的签名。</p><h3 id="关心一个『方法-x2F-类-x2F-接口-x2F-成员』在哪里被使用"><a href="#关心一个『方法-x2F-类-x2F-接口-x2F-成员』在哪里被使用" class="headerlink" title="关心一个『方法&#x2F;类&#x2F;接口&#x2F;成员』在哪里被使用"></a>关心一个『方法&#x2F;类&#x2F;接口&#x2F;成员』在哪里被使用</h3><p>先把光标放在『方法&#x2F;类&#x2F;接口&#x2F;成员』中间，然后按下<code>Alt + F7</code>，下方就会弹出一块展板对应展现其在整个项目中被使用的地方。而在一个类里关心一个成员变量或一个方法里一个变量被使用的位置，则光标在其中后按下<code>Shift +  Ctrl + F7</code>,会使使用其的所有地方高亮。在这之后可以用按下<code>F3</code>和<code>Shift + F3</code>在其中向前向后移动。</p><h3 id="在当前文件中的语法错误中来回移动"><a href="#在当前文件中的语法错误中来回移动" class="headerlink" title="在当前文件中的语法错误中来回移动"></a>在当前文件中的语法错误中来回移动</h3><p>下一个：<code>F2</code>，上一个：<code>Shift + F2</code>。</p><h3 id="快速跳转到具体实现的代码那边"><a href="#快速跳转到具体实现的代码那边" class="headerlink" title="快速跳转到具体实现的代码那边"></a>快速跳转到具体实现的代码那边</h3><p>按住<code>Ctrl</code>键后用鼠标单击感兴趣具体实现的目标，就会跳转到方法的具体实现的代码里。点击一个接口时<code>Ctrl + 鼠标单击</code>在还会智能推断这里最可能是用哪个实现而跳转到实现类的代码。如果按的是成员变量之类的不存在实现的，则会跳转到最接近的使用它的地方。</p><p><code>Ctrl + B</code>没有智能推断的能力，只会列出来让你选。但明确具体实现在哪里的话，用它效果一样。</p><h3 id="回到发生跳转前-x2F-回到-『回到发生跳转前』-前"><a href="#回到发生跳转前-x2F-回到-『回到发生跳转前』-前" class="headerlink" title="回到发生跳转前&#x2F;回到 『回到发生跳转前』 前"></a>回到发生跳转前&#x2F;回到 『回到发生跳转前』 前</h3><p><code>Ctrl + Alt</code>打底，前者再加<code>←</code>方向键，后者再加<code>→</code>方向键。</p><h3 id="列出当前类的方法和成员变量"><a href="#列出当前类的方法和成员变量" class="headerlink" title="列出当前类的方法和成员变量"></a>列出当前类的方法和成员变量</h3><p><code>Ctrl + F12</code>，列出后还能使用搜索并从中选择后快速跳转。</p><h3 id="git相关"><a href="#git相关" class="headerlink" title="git相关"></a>git相关</h3><p>按照[git 相关快捷键设置](#git 相关快捷键设置)中的设置。</p><h3 id="展开文件夹-x2F-packages"><a href="#展开文件夹-x2F-packages" class="headerlink" title="展开文件夹&#x2F;packages"></a>展开文件夹&#x2F;packages</h3><p>想快速一次性展开整个<code>src</code>文件夹，可以使用数字键盘中的<code>*</code>一次性展开到底，也可以使用方向键的右<code>→</code>展开一层。与之相反的则是数字键盘的<code>-</code>号，全部收回，以及方向键的左<code>←</code>收起一层。</p>]]></content>
    
    
    
    <tags>
      
      <tag>IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
